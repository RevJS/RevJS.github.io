{
    "docs": [
        {
            "location": "/",
            "text": "RevJS - Rev up your data-driven JS app development!\n\u00b6\n\n\nWhat is RevJS?\n\u00b6\n\n\nRevJS is a suite of JavaScript modules designed to speed up development of\ndata-driven JS applications.\n\n\nRevJS allows you to\n\n\n\n\nDefine a relational \ndata model\n using plain JS classes, and built-in or custom field types\n\n\nDefine custom \nvalidation logic\n directly in your models\n\n\nEasily create a \nGraphQL API\n to make your models available over the network\n\n\nQuickly build a \nuser interface\n for the web or mobile, using our React higher-order components\n\n\n\n\nExample\n\u00b6\n\n\nThe below example shows how to create a simple data model with RevJS's \nrev-models\n module:\n\n\n\nimport {\n    AutoNumberField, TextField, SelectField, IntegerField,\n    RelatedModel, ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define models\n\nexport class City {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        name: string;\n\n    constructor(data?: Partial<City>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Customer {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        first_name: string;\n    @TextField()\n        last_name: string;\n    @IntegerField()\n        age: number;\n    @SelectField({ selection: [['M', 'Male'], ['F', 'Female']] })\n        gender: string;\n    @RelatedModel({ model: 'City', required: false })\n        city: City;\n\n    constructor(data?: Partial<Customer>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager and register the models\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\n\nmodelManager.register(City);\nmodelManager.register(Customer);\n\n\n\n\nResJS is designed for use with \nTypeScript\n, to give you all the\nbenefits of strong typing and intellisense, however it should work with\nstandard ES6+ too. (we're looking for someone interested in creating and\nmaintaining a revjs ES6+ guide!...)\n\n\nComponents\n\u00b6\n\n\n\n\nrev-models\n - Define your Data Models and Validation,\n   and store and retrieve them from one of several \nbackends\n.\n\n\nrev-api\n - Expose your data model via an automatically-generated GraphQL API\n\n\nrev-api-client\n - Client-side wrapper for your API. Use your models\n   client-side in the same way you do on the server.\n\n\nrev-ui\n - Quickly build user interfaces with data from your RevJS backend using our\n  React higher-order components.\n\n\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!\n\n\nLicense\n\u00b6\n\n\nMIT",
            "title": "Welcome to RevJS!"
        },
        {
            "location": "/#revjs-rev-up-your-data-driven-js-app-development",
            "text": "",
            "title": "RevJS - Rev up your data-driven JS app development!"
        },
        {
            "location": "/#what-is-revjs",
            "text": "RevJS is a suite of JavaScript modules designed to speed up development of\ndata-driven JS applications.  RevJS allows you to   Define a relational  data model  using plain JS classes, and built-in or custom field types  Define custom  validation logic  directly in your models  Easily create a  GraphQL API  to make your models available over the network  Quickly build a  user interface  for the web or mobile, using our React higher-order components",
            "title": "What is RevJS?"
        },
        {
            "location": "/#example",
            "text": "The below example shows how to create a simple data model with RevJS's  rev-models  module:  \nimport {\n    AutoNumberField, TextField, SelectField, IntegerField,\n    RelatedModel, ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define models\n\nexport class City {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        name: string;\n\n    constructor(data?: Partial<City>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Customer {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        first_name: string;\n    @TextField()\n        last_name: string;\n    @IntegerField()\n        age: number;\n    @SelectField({ selection: [['M', 'Male'], ['F', 'Female']] })\n        gender: string;\n    @RelatedModel({ model: 'City', required: false })\n        city: City;\n\n    constructor(data?: Partial<Customer>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager and register the models\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\n\nmodelManager.register(City);\nmodelManager.register(Customer);  ResJS is designed for use with  TypeScript , to give you all the\nbenefits of strong typing and intellisense, however it should work with\nstandard ES6+ too. (we're looking for someone interested in creating and\nmaintaining a revjs ES6+ guide!...)",
            "title": "Example"
        },
        {
            "location": "/#components",
            "text": "rev-models  - Define your Data Models and Validation,\n   and store and retrieve them from one of several  backends .  rev-api  - Expose your data model via an automatically-generated GraphQL API  rev-api-client  - Client-side wrapper for your API. Use your models\n   client-side in the same way you do on the server.  rev-ui  - Quickly build user interfaces with data from your RevJS backend using our\n  React higher-order components.",
            "title": "Components"
        },
        {
            "location": "/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/#license",
            "text": "MIT",
            "title": "License"
        },
        {
            "location": "/using_models/creating_models/",
            "text": "Creating your Data Model\n\u00b6\n\n\nDefining Models\n\u00b6\n\n\nA \"Model\" in RevJS is simply a JavaScript Class with some additional properties\nthat tell RevJS how to validate, store and retrieve data.\n\n\nIf you are using \nTypeScript\n, then you can use decorators to easily define\nthe properties of your model.\n\n\nIn order to use your model classes, you must register them using the\n\nregister()\n method of a\n\nModelManager\n instance.\n\n\nThe example below shows how to create two related models, and register them\nwith a ModelManager:\n\n\n\nimport {\n    AutoNumberField, TextField, SelectField, IntegerField,\n    RelatedModel, ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define models\n\nexport class City {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        name: string;\n\n    constructor(data?: Partial<City>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Customer {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        first_name: string;\n    @TextField()\n        last_name: string;\n    @IntegerField()\n        age: number;\n    @SelectField({ selection: [['M', 'Male'], ['F', 'Female']] })\n        gender: string;\n    @RelatedModel({ model: 'City', required: false })\n        city: City;\n\n    constructor(data?: Partial<Customer>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager and register the models\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\n\nmodelManager.register(City);\nmodelManager.register(Customer);\n\n\n\n\nBuilt-in Field Types\n\u00b6\n\n\nRevJS ships with a set 15 standard field types, and you can also create your own\nby extending the \nField\n class.\n\n\n\n\nTextField\n - Single, or multi-line text field\n\n\nEmailField\n - TextField with e-mail address validation\n\n\nUrlField\n - TextField with URL validation\n\n\nPasswordField\n - Password field\n\n\nNumberField\n - Number entry field (any numeric value)\n\n\nIntegerField\n - Integer entry field\n\n\nAutoNumberField\n - Auto-generated, sequential integer field\n\n\nBooleanField\n - True / false\n\n\nSelectField\n - Single-item selection field\n\n\nMultiSelectField\n - Multiple-item selection field\n\n\nDateField\n - Date-only field\n\n\nTimeField\n - Time-only field\n\n\nDateTimeField\n - Date & Time field\n\n\nRelatedModelField\n - Foreign-key link to a related model\n\n\nRelatedModelListField\n - List of related models",
            "title": "Defining Models"
        },
        {
            "location": "/using_models/creating_models/#creating-your-data-model",
            "text": "",
            "title": "Creating your Data Model"
        },
        {
            "location": "/using_models/creating_models/#defining-models",
            "text": "A \"Model\" in RevJS is simply a JavaScript Class with some additional properties\nthat tell RevJS how to validate, store and retrieve data.  If you are using  TypeScript , then you can use decorators to easily define\nthe properties of your model.  In order to use your model classes, you must register them using the register()  method of a ModelManager  instance.  The example below shows how to create two related models, and register them\nwith a ModelManager:  \nimport {\n    AutoNumberField, TextField, SelectField, IntegerField,\n    RelatedModel, ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define models\n\nexport class City {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        name: string;\n\n    constructor(data?: Partial<City>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Customer {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        first_name: string;\n    @TextField()\n        last_name: string;\n    @IntegerField()\n        age: number;\n    @SelectField({ selection: [['M', 'Male'], ['F', 'Female']] })\n        gender: string;\n    @RelatedModel({ model: 'City', required: false })\n        city: City;\n\n    constructor(data?: Partial<Customer>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager and register the models\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\n\nmodelManager.register(City);\nmodelManager.register(Customer);",
            "title": "Defining Models"
        },
        {
            "location": "/using_models/creating_models/#built-in-field-types",
            "text": "RevJS ships with a set 15 standard field types, and you can also create your own\nby extending the  Field  class.   TextField  - Single, or multi-line text field  EmailField  - TextField with e-mail address validation  UrlField  - TextField with URL validation  PasswordField  - Password field  NumberField  - Number entry field (any numeric value)  IntegerField  - Integer entry field  AutoNumberField  - Auto-generated, sequential integer field  BooleanField  - True / false  SelectField  - Single-item selection field  MultiSelectField  - Multiple-item selection field  DateField  - Date-only field  TimeField  - Time-only field  DateTimeField  - Date & Time field  RelatedModelField  - Foreign-key link to a related model  RelatedModelListField  - List of related models",
            "title": "Built-in Field Types"
        },
        {
            "location": "/using_models/model_validation/",
            "text": "Defining Data Validation\n\u00b6\n\n\nOne of the major benefits of using JavaScript on both the Client and Server is\nthe ability to share business logic and validations across both platforms.\n\n\nRevJS provides two main methods of validating your data.\n\n\n\n\nField-level validation, using the built-in field types or your own custom\n   field types.\n\n\nModel-level validation, by defining a \nvalidate()\n or \nvalidateAsync()\n\n   method on your model.\n\n\n\n\nUsing Field-level validation\n\u00b6\n\n\nThe build-in field types have a number of configurable validation options,\nwhich can be set directly on your models. For example:\n\n\nclass MyClass {\n    @TextField({ maxLength: 100, regEx: /abc/ })\n        name: string;\n}\n\n\n\n\nFor more information on the options available for each field type, check out\nthe \nIFieldOptions interface\n\nand its sub-classes.\n\n\nUsing Model-level validation\n\u00b6\n\n\nYou can implement more complex validation logic in a\n\nvalidate()\n or\n\nvalidateAsync()\n method\ndirectly in your model.\n\n\nRevJS will call these methods for every \ncreate\n or \nupdate\n operation. You\nsimply check the property values of \nthis.\n to determine if the model is valid.\n\n\nRevJS passes in a single\n\nIValidationContext\n\nparameter to the validation functions, which you can use to find out more about\nthe validation context. For example you can check \nctx.operation.operationName\n\nto determine if this is a \ncreate\n or \nupdate\n.\n\n\nIf there is a validation error, you can record a field-level error by calling\n\nctx.result.addFieldError()\n,\nor you can record a model-level error by calling\n\nctx.result.addModelError()\n,\n\n\nThe example below demonstrates how to use both field-level and model-level validation.\n\n\n\nimport {\n    AutoNumberField, TextField, BooleanField,\n    ModelManager, InMemoryBackend, IValidationContext\n} from 'rev-models';\n\n// Define model with some custom validation\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @BooleanField()\n        is_published: boolean;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n\n    // Define synchronous validation\n    validate(ctx: IValidationContext) {\n        if (this.body.includes('fake news')) {\n            ctx.result.addFieldError('body', 'Body must not contain fake news!');\n        }\n    }\n\n    // Define some asynchronous validation\n    async validateAsync(ctx: IValidationContext) {\n        if (ctx.operation.operationName == 'create') {\n            const duplicates = await ctx.manager.read(Post, {\n                where: {\n                    title: { _like: this.title }\n                }\n            });\n            if (duplicates.meta.totalCount > 0) {\n                ctx.result.addFieldError('title', 'Cannot create post with a duplicate title!');\n            }\n        }\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n// Create some data\n\n(async () => {\n    try {\n\n        // Create a valid post\n        await modelManager.create(new Post({\n            title: 'This is a valid post',\n            body: 'No alternative facts here!',\n            is_published: true\n        }));\n\n        // Try to create a duplicate post...\n        await modelManager.create(new Post({\n            title: 'This is a valid post',\n            body: 'Not really! Its a duplicate, so should cause an error...',\n            is_published: true\n        }));\n\n    }\n    catch (e) {\n        console.error(e.message);\n    }\n})();\n\n\n\n\nThe output of the above code is:\n\n\nValidationError\n * title: Cannot create post with a duplicate title!",
            "title": "Adding Validation"
        },
        {
            "location": "/using_models/model_validation/#defining-data-validation",
            "text": "One of the major benefits of using JavaScript on both the Client and Server is\nthe ability to share business logic and validations across both platforms.  RevJS provides two main methods of validating your data.   Field-level validation, using the built-in field types or your own custom\n   field types.  Model-level validation, by defining a  validate()  or  validateAsync() \n   method on your model.",
            "title": "Defining Data Validation"
        },
        {
            "location": "/using_models/model_validation/#using-field-level-validation",
            "text": "The build-in field types have a number of configurable validation options,\nwhich can be set directly on your models. For example:  class MyClass {\n    @TextField({ maxLength: 100, regEx: /abc/ })\n        name: string;\n}  For more information on the options available for each field type, check out\nthe  IFieldOptions interface \nand its sub-classes.",
            "title": "Using Field-level validation"
        },
        {
            "location": "/using_models/model_validation/#using-model-level-validation",
            "text": "You can implement more complex validation logic in a validate()  or validateAsync()  method\ndirectly in your model.  RevJS will call these methods for every  create  or  update  operation. You\nsimply check the property values of  this.  to determine if the model is valid.  RevJS passes in a single IValidationContext \nparameter to the validation functions, which you can use to find out more about\nthe validation context. For example you can check  ctx.operation.operationName \nto determine if this is a  create  or  update .  If there is a validation error, you can record a field-level error by calling ctx.result.addFieldError() ,\nor you can record a model-level error by calling ctx.result.addModelError() ,  The example below demonstrates how to use both field-level and model-level validation.  \nimport {\n    AutoNumberField, TextField, BooleanField,\n    ModelManager, InMemoryBackend, IValidationContext\n} from 'rev-models';\n\n// Define model with some custom validation\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @BooleanField()\n        is_published: boolean;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n\n    // Define synchronous validation\n    validate(ctx: IValidationContext) {\n        if (this.body.includes('fake news')) {\n            ctx.result.addFieldError('body', 'Body must not contain fake news!');\n        }\n    }\n\n    // Define some asynchronous validation\n    async validateAsync(ctx: IValidationContext) {\n        if (ctx.operation.operationName == 'create') {\n            const duplicates = await ctx.manager.read(Post, {\n                where: {\n                    title: { _like: this.title }\n                }\n            });\n            if (duplicates.meta.totalCount > 0) {\n                ctx.result.addFieldError('title', 'Cannot create post with a duplicate title!');\n            }\n        }\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n// Create some data\n\n(async () => {\n    try {\n\n        // Create a valid post\n        await modelManager.create(new Post({\n            title: 'This is a valid post',\n            body: 'No alternative facts here!',\n            is_published: true\n        }));\n\n        // Try to create a duplicate post...\n        await modelManager.create(new Post({\n            title: 'This is a valid post',\n            body: 'Not really! Its a duplicate, so should cause an error...',\n            is_published: true\n        }));\n\n    }\n    catch (e) {\n        console.error(e.message);\n    }\n})();  The output of the above code is:  ValidationError\n * title: Cannot create post with a duplicate title!",
            "title": "Using Model-level validation"
        },
        {
            "location": "/using_models/revjs_backends/",
            "text": "RevJS Backends\n\u00b6\n\n\nRevJS has a \npluggable backend architecture\n, to allow you to store your\nmodels in a variety of databases, and send them across the network using APIs.\n\n\nUsing a Backend\n\u00b6\n\n\nYou specify a backend when you create an instance of a\n\nModelManager\n, for example:\n\n\nconst manager = new ModelManager();\nmanager.registerBackend('default', new InMemoryBackend());\n\n\n\n\nIf you have data in multiple databases or APIs, you can register\nmore than one backend for a model manager.\n\n\nWhen registering your models, you can tell the ModelManager which backend to\nsource them from. For example:\n\n\nmanager.register(TestModel, { backend: 'customer_db' });\n\n\n\n\nIf you do not specify a backend when registering your model, then the\n\ndefault\n backend is used.\n\n\nPersistant Storage Backends\n\u00b6\n\n\n\n\nMongoDBBackend\n -\n   stores and retrieves your data from MongoDB\n\n\n\n\nAPI Backends\n\u00b6\n\n\n\n\nModelApiBackend\n -\n   store and retrieve data from a GraphQL API created by the \nrev-api\n module\n\n\n\n\nEphemeral Backends\n\u00b6\n\n\n\n\nInMemoryBackend\n - stores your\n   model data temporarily in-memory. Ideal for initial development and automated\n   testing.\n\n\n\n\nContributing\n\u00b6\n\n\nWe have defined a standard \nIBackend\n\ninterface, as well as a\n\nStandard Test Suite\n\nto help with new backend development. We're keen to accept any contributions\nfrom the community!",
            "title": "Storage Backends"
        },
        {
            "location": "/using_models/revjs_backends/#revjs-backends",
            "text": "RevJS has a  pluggable backend architecture , to allow you to store your\nmodels in a variety of databases, and send them across the network using APIs.",
            "title": "RevJS Backends"
        },
        {
            "location": "/using_models/revjs_backends/#using-a-backend",
            "text": "You specify a backend when you create an instance of a ModelManager , for example:  const manager = new ModelManager();\nmanager.registerBackend('default', new InMemoryBackend());  If you have data in multiple databases or APIs, you can register\nmore than one backend for a model manager.  When registering your models, you can tell the ModelManager which backend to\nsource them from. For example:  manager.register(TestModel, { backend: 'customer_db' });  If you do not specify a backend when registering your model, then the default  backend is used.",
            "title": "Using a Backend"
        },
        {
            "location": "/using_models/revjs_backends/#persistant-storage-backends",
            "text": "MongoDBBackend  -\n   stores and retrieves your data from MongoDB",
            "title": "Persistant Storage Backends"
        },
        {
            "location": "/using_models/revjs_backends/#api-backends",
            "text": "ModelApiBackend  -\n   store and retrieve data from a GraphQL API created by the  rev-api  module",
            "title": "API Backends"
        },
        {
            "location": "/using_models/revjs_backends/#ephemeral-backends",
            "text": "InMemoryBackend  - stores your\n   model data temporarily in-memory. Ideal for initial development and automated\n   testing.",
            "title": "Ephemeral Backends"
        },
        {
            "location": "/using_models/revjs_backends/#contributing",
            "text": "We have defined a standard  IBackend \ninterface, as well as a Standard Test Suite \nto help with new backend development. We're keen to accept any contributions\nfrom the community!",
            "title": "Contributing"
        },
        {
            "location": "/using_models/creating_data/",
            "text": "Creating Model Data\n\u00b6\n\n\nSince RevJS models are just JavaScript classes, you create new records by\ncreating new instances of your model class, and passing them to the\n\nModelManager.create()\n\nmethod.\n\n\nDefining Model Constructors\n\u00b6\n\n\nTo make it easier to populate new records, we recommend adding a constructor\nfunction to your class, as shown in the example below:\n\n\nclass MyCoolModel {\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n\n    constructor(data?: Partial<MyCoolModel>) {\n        Object.assign(this, data);\n    }\n}\n\n\n\n\nDoing this means you can then construct new records with new data in a single\nstatement, as shown below:\n\n\nconst new_record = new MyCoolModel({\n    title: 'New Record',\n    body: 'This is a cool new record with some data!'\n});\n\n\n\n\nIMPORTANT NOTE:\n It should also be possible to construct instances\nof your model \nwithout\n passing any data. RevJS needs to do this when\nhydrating models from data retrieved from a backend.\n\n\nStoring Model Data\n\u00b6\n\n\nTo store data for your model in a backend, simply pass a populated instance\nof your model to the\n\nModelManager.create()\n\nmethod.\n\n\nThe model data will be validated before it is passed to the backend. If any\nvalidation errors occur, a\n\nValidationError\n will be\nthrown.\n\n\nThe example below shows how to define a model and create some data for it:\n\n\n\nimport {\n    AutoNumberField, TextField, SelectField,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define model\n\nconst POST_STATUS = [\n    ['draft', 'Draft'],\n    ['published', 'Published']\n];\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField({ minLength: 5, maxLength: 100 })\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @SelectField({ selection: POST_STATUS })\n        status: string;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n(async () => {\n\n    // Create some data\n\n    await modelManager.create(new Post({\n        title: 'My First Post',\n        body: 'This is a really cool post made in RevJS',\n        status: 'draft'\n    }));\n\n    await modelManager.create(new Post({\n        title: 'RevJS is awesome!',\n        body: 'I should use it for ALL TEH THINGZZZ!',\n        status: 'published'\n    }));\n\n    // Read it back\n\n    const res = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { title: { _like: '%RevJS%' }},\n                { body: { _like: '%RevJS%' }}\n            ]\n        }\n    });\n\n    console.log(res.results);\n\n})();",
            "title": "Creating Data"
        },
        {
            "location": "/using_models/creating_data/#creating-model-data",
            "text": "Since RevJS models are just JavaScript classes, you create new records by\ncreating new instances of your model class, and passing them to the ModelManager.create() \nmethod.",
            "title": "Creating Model Data"
        },
        {
            "location": "/using_models/creating_data/#defining-model-constructors",
            "text": "To make it easier to populate new records, we recommend adding a constructor\nfunction to your class, as shown in the example below:  class MyCoolModel {\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n\n    constructor(data?: Partial<MyCoolModel>) {\n        Object.assign(this, data);\n    }\n}  Doing this means you can then construct new records with new data in a single\nstatement, as shown below:  const new_record = new MyCoolModel({\n    title: 'New Record',\n    body: 'This is a cool new record with some data!'\n});  IMPORTANT NOTE:  It should also be possible to construct instances\nof your model  without  passing any data. RevJS needs to do this when\nhydrating models from data retrieved from a backend.",
            "title": "Defining Model Constructors"
        },
        {
            "location": "/using_models/creating_data/#storing-model-data",
            "text": "To store data for your model in a backend, simply pass a populated instance\nof your model to the ModelManager.create() \nmethod.  The model data will be validated before it is passed to the backend. If any\nvalidation errors occur, a ValidationError  will be\nthrown.  The example below shows how to define a model and create some data for it:  \nimport {\n    AutoNumberField, TextField, SelectField,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define model\n\nconst POST_STATUS = [\n    ['draft', 'Draft'],\n    ['published', 'Published']\n];\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField({ minLength: 5, maxLength: 100 })\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @SelectField({ selection: POST_STATUS })\n        status: string;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n(async () => {\n\n    // Create some data\n\n    await modelManager.create(new Post({\n        title: 'My First Post',\n        body: 'This is a really cool post made in RevJS',\n        status: 'draft'\n    }));\n\n    await modelManager.create(new Post({\n        title: 'RevJS is awesome!',\n        body: 'I should use it for ALL TEH THINGZZZ!',\n        status: 'published'\n    }));\n\n    // Read it back\n\n    const res = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { title: { _like: '%RevJS%' }},\n                { body: { _like: '%RevJS%' }}\n            ]\n        }\n    });\n\n    console.log(res.results);\n\n})();",
            "title": "Storing Model Data"
        },
        {
            "location": "/using_models/reading_data/",
            "text": "Reading Model Data\n\u00b6\n\n\nOnce you have defined your models and created some data, you can read it back\nusing the\n\nModelManager.read()\n method.\n\n\nReading All Data\n\u00b6\n\n\nTo read all model data without applying any filters, simply pass the model\nclass to your ModelManager's \nread()\n function:\n\n\n\nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    const res = await modelManager.read(Post);\n\n    for (let post of res.results) {\n        console.log(post.title);\n    }\n})();\n\n\n\n\nIMPORTANT NOTE:\n To encourage use of paging, the \nread()\n function will\nonly return \nthe first 20 records\n by default. See below for how to use the\n\nlimit\n and \noffset\n options to \npage\n through the data.\n\n\nSearching for Data\n\u00b6\n\n\nRevJS uses a MongoDB-like query language for building search queries. Below are\nsome examples:\n\n\n\nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Find all posts in the 'technology' category that are published\n    const techPosts = await modelManager.read(Post, {\n        where: {\n            category: 'technology',\n            published: true\n        }\n    });\n    console.log('Tech Posts:', techPosts.results);\n\n    // Find all published posts in the 'science' OR 'technology' categories\n    const sciTechPosts = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { category: 'science' },\n                { category: 'technology' }\n            ],\n            published: true\n        }\n    });\n    console.log('Science & Technology Posts:', sciTechPosts.results);\n\n    // Find all posts with a rating greater than or equal to 3\n    const goodPosts = await modelManager.read(Post, {\n        where: {\n            rating: { _gte: 3 }\n        }\n    });\n    console.log('Good Posts:', goodPosts.results);\n\n})();\n\n\n\n\nRevJS Query Operators\n\u00b6\n\n\nLogical Operators\n\u00b6\n\n\nThese operators take an array of conditions (as per the \n_or\n example above).\n\n\n\n\n_and\n - all conditions in the array must be true\n\n\n_or\n - at least one of the conditions in the array must be true\n\n\n\n\nValue Operators\n\u00b6\n\n\nThese operators take a single value (as per the \n_gte\n example above).\n\n\n\n\n_eq\n - equals - field must exactly match the specified value\n\n\n_neq\n - not equals - field must not match the specified value\n\n\n_gt\n - greater than - field must be greater than the specified value\n\n\n_gte\n - greater than or equal to - field must be greater than or equal to the specified value\n\n\n_lt\n - less than - field must be less than the specified value\n\n\n_lte\n - less than or equal to - field must be less than or equal to the specified value\n\n\n_like\n - like - field must be like the specified value, which can include \n%\n symbols to match multiple characters (works as per the traditional SQL 'LIKE' clause)\n\n\n\n\nValue List Operators\n\u00b6\n\n\nThese operators take an array of values.\n\n\n\n\n_in\n - in - field must match one of the values in the array\n\n\n_nin\n - not in - field must not match any of the values in the array\n\n\n\n\nUsing \nlimit\n and \noffset\n\u00b6\n\n\nYou can use the \nlimit\n and \noffset\n options with the\n\nread()\n method, to\n\npage\n through query results, as shown in the examples below:\n\n\n\nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Get the first 3 published posts\n    const first3Posts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        offset: 0,\n        limit: 3\n    });\n    console.log('First 3 Published Posts:', first3Posts.results);\n\n    // Get the next 3 published posts\n    const next3Posts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        offset: 3,\n        limit: 3\n    });\n    console.log('Next 3 Posts:', next3Posts.results);\n\n    // Just get all the published posts (max 100)\n    const allPosts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        limit: 100\n    });\n    console.log('All Teh Posts:', allPosts.results);\n\n})();\n\n\n\n\nSorting Data\n\u00b6\n\n\nYou can use the \norderBy\n option to specify the order of the records that are\nretrieved from the backend. This option takes an array of field names, and the\nrecords are sorted by each of the specified fields, in order. You can optionally\nuse the \ndesc\n keyword after the field name, to sort the values in that field\nin descending order.\n\n\n\nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Read all published posts, sorted by Title\n    const postsByTitle = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        limit: 100,\n        orderBy: ['title']\n    });\n    console.log('Posts by Title:', postsByTitle.results);\n\n    // Read all posts, sorted by Title in descending order\n    const postsByTitleDesc = await modelManager.read(Post, {\n        limit: 100,\n        orderBy: ['title desc']\n    });\n    console.log('Posts by Titie in descending order:', postsByTitleDesc.results);\n\n    // Read the first 10 posts sorted by Rating, then by Title\n    const top10Posts = await modelManager.read(Post, {\n        limit: 10,\n        orderBy: ['rating desc', 'title']\n    });\n    console.log('Top Posts:', top10Posts.results);\n\n})();",
            "title": "Reading Data"
        },
        {
            "location": "/using_models/reading_data/#reading-model-data",
            "text": "Once you have defined your models and created some data, you can read it back\nusing the ModelManager.read()  method.",
            "title": "Reading Model Data"
        },
        {
            "location": "/using_models/reading_data/#reading-all-data",
            "text": "To read all model data without applying any filters, simply pass the model\nclass to your ModelManager's  read()  function:  \nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    const res = await modelManager.read(Post);\n\n    for (let post of res.results) {\n        console.log(post.title);\n    }\n})();  IMPORTANT NOTE:  To encourage use of paging, the  read()  function will\nonly return  the first 20 records  by default. See below for how to use the limit  and  offset  options to  page  through the data.",
            "title": "Reading All Data"
        },
        {
            "location": "/using_models/reading_data/#searching-for-data",
            "text": "RevJS uses a MongoDB-like query language for building search queries. Below are\nsome examples:  \nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Find all posts in the 'technology' category that are published\n    const techPosts = await modelManager.read(Post, {\n        where: {\n            category: 'technology',\n            published: true\n        }\n    });\n    console.log('Tech Posts:', techPosts.results);\n\n    // Find all published posts in the 'science' OR 'technology' categories\n    const sciTechPosts = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { category: 'science' },\n                { category: 'technology' }\n            ],\n            published: true\n        }\n    });\n    console.log('Science & Technology Posts:', sciTechPosts.results);\n\n    // Find all posts with a rating greater than or equal to 3\n    const goodPosts = await modelManager.read(Post, {\n        where: {\n            rating: { _gte: 3 }\n        }\n    });\n    console.log('Good Posts:', goodPosts.results);\n\n})();",
            "title": "Searching for Data"
        },
        {
            "location": "/using_models/reading_data/#revjs-query-operators",
            "text": "",
            "title": "RevJS Query Operators"
        },
        {
            "location": "/using_models/reading_data/#logical-operators",
            "text": "These operators take an array of conditions (as per the  _or  example above).   _and  - all conditions in the array must be true  _or  - at least one of the conditions in the array must be true",
            "title": "Logical Operators"
        },
        {
            "location": "/using_models/reading_data/#value-operators",
            "text": "These operators take a single value (as per the  _gte  example above).   _eq  - equals - field must exactly match the specified value  _neq  - not equals - field must not match the specified value  _gt  - greater than - field must be greater than the specified value  _gte  - greater than or equal to - field must be greater than or equal to the specified value  _lt  - less than - field must be less than the specified value  _lte  - less than or equal to - field must be less than or equal to the specified value  _like  - like - field must be like the specified value, which can include  %  symbols to match multiple characters (works as per the traditional SQL 'LIKE' clause)",
            "title": "Value Operators"
        },
        {
            "location": "/using_models/reading_data/#value-list-operators",
            "text": "These operators take an array of values.   _in  - in - field must match one of the values in the array  _nin  - not in - field must not match any of the values in the array",
            "title": "Value List Operators"
        },
        {
            "location": "/using_models/reading_data/#using-limit-and-offset",
            "text": "You can use the  limit  and  offset  options with the read()  method, to page  through query results, as shown in the examples below:  \nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Get the first 3 published posts\n    const first3Posts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        offset: 0,\n        limit: 3\n    });\n    console.log('First 3 Published Posts:', first3Posts.results);\n\n    // Get the next 3 published posts\n    const next3Posts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        offset: 3,\n        limit: 3\n    });\n    console.log('Next 3 Posts:', next3Posts.results);\n\n    // Just get all the published posts (max 100)\n    const allPosts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        limit: 100\n    });\n    console.log('All Teh Posts:', allPosts.results);\n\n})();",
            "title": "Using limit and offset"
        },
        {
            "location": "/using_models/reading_data/#sorting-data",
            "text": "You can use the  orderBy  option to specify the order of the records that are\nretrieved from the backend. This option takes an array of field names, and the\nrecords are sorted by each of the specified fields, in order. You can optionally\nuse the  desc  keyword after the field name, to sort the values in that field\nin descending order.  \nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Read all published posts, sorted by Title\n    const postsByTitle = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        limit: 100,\n        orderBy: ['title']\n    });\n    console.log('Posts by Title:', postsByTitle.results);\n\n    // Read all posts, sorted by Title in descending order\n    const postsByTitleDesc = await modelManager.read(Post, {\n        limit: 100,\n        orderBy: ['title desc']\n    });\n    console.log('Posts by Titie in descending order:', postsByTitleDesc.results);\n\n    // Read the first 10 posts sorted by Rating, then by Title\n    const top10Posts = await modelManager.read(Post, {\n        limit: 10,\n        orderBy: ['rating desc', 'title']\n    });\n    console.log('Top Posts:', top10Posts.results);\n\n})();",
            "title": "Sorting Data"
        },
        {
            "location": "/using_models/updating_data/",
            "text": "Updating Model Data\n\u00b6\n\n\nYou can update records using the\n\nModelManager.update()\n\nmethod. There are a couple of ways to use it:\n\n\nUpdating Data from Reads\n\u00b6\n\n\nIf you have retrieved some data via a\n\nread()\n operation, then you\ncan update the retrieved records directly, as shown in the example below:\n\n\nimport { City, modelManager } from './creating_models';\n\n(async () => {\n\n    await modelManager.create(new City({ name: 'Wellington' }));\n    await modelManager.create(new City({ name: 'Auckland' }));\n    await modelManager.create(new City({ name: 'Hamilton' }));\n    await modelManager.create(new City({ name: 'Christchurch' }));\n\n    // Retrieve Auckland's record\n    const cities = await modelManager.read(City, { where: {\n            name: 'Auckland'\n    }});\n    console.log('Original Record:', cities.results[0]);\n\n    // Change it's name and trigger an update\n    const auckland = cities.results[0];\n    auckland.name = 'City of Sails';\n\n    await modelManager.update(auckland);\n\n    // Check that Auckland's record has been updated\n    const cityRetrieved = await modelManager.read(City, { where: {\n            name: 'City of Sails'\n    }});\n    console.log('Updated Record:', cityRetrieved.results[0]);\n\n})();\n\n\n\n\nNOTE:\n In order to update records without specifying a \nwhere\n clause, your\nmodel must have a field with \nprimaryKey: true\n set.\n\n\nUpdating Data with a Where clause\n\u00b6\n\n\nIf you wish to modify one or more fields across \nmultiple records\n, you can\nuse the \nwhere\n clause, as shown in the example below:\n\n\nimport { Post, modelManager, createData } from './post_model';\n\n(async () => {\n    await createData();\n\n    // Count unpublished posts\n    const unpublishedPosts = await modelManager.read(Post, {\n        where: {\n            published: false\n        }\n    });\n    console.log('Number of unpublished posts:', unpublishedPosts.meta.totalCount);\n\n    // Publish all unpublished posts!\n    const publishResult = await modelManager.update(\n        new Post({\n            published: true\n        }),\n        {\n            where: {\n                published: false\n            }\n        }\n    );\n    console.log('Updated records:', publishResult.meta.totalCount);\n\n})();",
            "title": "Updating Data"
        },
        {
            "location": "/using_models/updating_data/#updating-model-data",
            "text": "You can update records using the ModelManager.update() \nmethod. There are a couple of ways to use it:",
            "title": "Updating Model Data"
        },
        {
            "location": "/using_models/updating_data/#updating-data-from-reads",
            "text": "If you have retrieved some data via a read()  operation, then you\ncan update the retrieved records directly, as shown in the example below:  import { City, modelManager } from './creating_models';\n\n(async () => {\n\n    await modelManager.create(new City({ name: 'Wellington' }));\n    await modelManager.create(new City({ name: 'Auckland' }));\n    await modelManager.create(new City({ name: 'Hamilton' }));\n    await modelManager.create(new City({ name: 'Christchurch' }));\n\n    // Retrieve Auckland's record\n    const cities = await modelManager.read(City, { where: {\n            name: 'Auckland'\n    }});\n    console.log('Original Record:', cities.results[0]);\n\n    // Change it's name and trigger an update\n    const auckland = cities.results[0];\n    auckland.name = 'City of Sails';\n\n    await modelManager.update(auckland);\n\n    // Check that Auckland's record has been updated\n    const cityRetrieved = await modelManager.read(City, { where: {\n            name: 'City of Sails'\n    }});\n    console.log('Updated Record:', cityRetrieved.results[0]);\n\n})();  NOTE:  In order to update records without specifying a  where  clause, your\nmodel must have a field with  primaryKey: true  set.",
            "title": "Updating Data from Reads"
        },
        {
            "location": "/using_models/updating_data/#updating-data-with-a-where-clause",
            "text": "If you wish to modify one or more fields across  multiple records , you can\nuse the  where  clause, as shown in the example below:  import { Post, modelManager, createData } from './post_model';\n\n(async () => {\n    await createData();\n\n    // Count unpublished posts\n    const unpublishedPosts = await modelManager.read(Post, {\n        where: {\n            published: false\n        }\n    });\n    console.log('Number of unpublished posts:', unpublishedPosts.meta.totalCount);\n\n    // Publish all unpublished posts!\n    const publishResult = await modelManager.update(\n        new Post({\n            published: true\n        }),\n        {\n            where: {\n                published: false\n            }\n        }\n    );\n    console.log('Updated records:', publishResult.meta.totalCount);\n\n})();",
            "title": "Updating Data with a Where clause"
        },
        {
            "location": "/using_models/deleting_data/",
            "text": "Deleting Model Data\n\u00b6\n\n\nYou can delete records using the\n\nModelManager.remove()\n\nmethod ('delete' is a reserved word in JavaScript). There are a couple of ways to use the remove() method:\n\n\nDeleting Data from Reads\n\u00b6\n\n\nIf you have retrieved some data via a\n\nread()\n operation, then you\ncan remove the retrieved records directly, as shown in the example below:\n\n\n\nimport { City, modelManager } from './creating_models';\n\n(async () => {\n\n    await modelManager.create(new City({ name: 'Wellington' }));\n    await modelManager.create(new City({ name: 'Auckland' }));\n    await modelManager.create(new City({ name: 'Hamilton' }));\n    await modelManager.create(new City({ name: 'Christchurch' }));\n\n    const origRecords = await modelManager.read(City);\n    console.log('Original Records:', origRecords.results);\n\n    // Retrieve Auckland\n    const cities = await modelManager.read(City, { where: {\n        name: 'Auckland'\n    }});\n\n    // Remove it!\n    await modelManager.remove(cities.results[0]);\n\n    // Retrieve remaining records\n    const newRecords = await modelManager.read(City);\n    console.log('Remaining Records:', newRecords.results);\n\n})();\n\n\n\n\nNOTE:\n In order to remove records without specifying a \nwhere\n clause, your\nmodel must have a field with \nprimaryKey: true\n set.\n\n\nDeleting Data with a Where clause\n\u00b6\n\n\nIf you wish to delete multiple records, you can\nuse the \nwhere\n clause, as shown in the example below:\n\n\nimport { Post, modelManager, createData } from './post_model';\n\n(async () => {\n    await createData();\n\n    // Count unpublished posts\n    const unpublishedPosts = await modelManager.read(Post, {\n        where: {\n            published: false\n        }\n    });\n    console.log('Number of unpublished posts:', unpublishedPosts.meta.totalCount);\n\n    // Delete all unpublished posts\n    const deleteResult = await modelManager.remove(new Post(), {\n        where: {\n            published: false\n        }\n    });\n    console.log('Deleted records:', deleteResult.meta.totalCount);\n\n})();",
            "title": "Deleting Data"
        },
        {
            "location": "/using_models/deleting_data/#deleting-model-data",
            "text": "You can delete records using the ModelManager.remove() \nmethod ('delete' is a reserved word in JavaScript). There are a couple of ways to use the remove() method:",
            "title": "Deleting Model Data"
        },
        {
            "location": "/using_models/deleting_data/#deleting-data-from-reads",
            "text": "If you have retrieved some data via a read()  operation, then you\ncan remove the retrieved records directly, as shown in the example below:  \nimport { City, modelManager } from './creating_models';\n\n(async () => {\n\n    await modelManager.create(new City({ name: 'Wellington' }));\n    await modelManager.create(new City({ name: 'Auckland' }));\n    await modelManager.create(new City({ name: 'Hamilton' }));\n    await modelManager.create(new City({ name: 'Christchurch' }));\n\n    const origRecords = await modelManager.read(City);\n    console.log('Original Records:', origRecords.results);\n\n    // Retrieve Auckland\n    const cities = await modelManager.read(City, { where: {\n        name: 'Auckland'\n    }});\n\n    // Remove it!\n    await modelManager.remove(cities.results[0]);\n\n    // Retrieve remaining records\n    const newRecords = await modelManager.read(City);\n    console.log('Remaining Records:', newRecords.results);\n\n})();  NOTE:  In order to remove records without specifying a  where  clause, your\nmodel must have a field with  primaryKey: true  set.",
            "title": "Deleting Data from Reads"
        },
        {
            "location": "/using_models/deleting_data/#deleting-data-with-a-where-clause",
            "text": "If you wish to delete multiple records, you can\nuse the  where  clause, as shown in the example below:  import { Post, modelManager, createData } from './post_model';\n\n(async () => {\n    await createData();\n\n    // Count unpublished posts\n    const unpublishedPosts = await modelManager.read(Post, {\n        where: {\n            published: false\n        }\n    });\n    console.log('Number of unpublished posts:', unpublishedPosts.meta.totalCount);\n\n    // Delete all unpublished posts\n    const deleteResult = await modelManager.remove(new Post(), {\n        where: {\n            published: false\n        }\n    });\n    console.log('Deleted records:', deleteResult.meta.totalCount);\n\n})();",
            "title": "Deleting Data with a Where clause"
        },
        {
            "location": "/using_models/related_data/",
            "text": "Working with Related Models\n\u00b6\n\n\nTo fully model your data, you will normally want to define relationships\nbetween your models.\n\n\nFor example, you might want to associate a \nPost\n model with a \nUser\n (the\nauthor), and also your \nPost\n model may have many \nComments\n linked with it.\n\n\nDefining Relationships\n\u00b6\n\n\nRevJS currently has two types of relational fields:\n\n\n\n\nA \nRelatedModel\n field is a\n  link from the current model to \none record from another model\n. In the\n  \nPost\n example above, you would add a \n@RelatedModel()\n field for the\n  \nuser\n field.\n\n\nA \nRelatedModelList\n\n  field allows access to \na list of records from another model\n, that are\n  linked to the current one via a RelatedModel field. In the \nPost\n example\n  above, you would add a \n@RelatedModelList()\n field for the \ncomments\n field.\n\n\n\n\nLets implement the \nPost\n, \nUser\n, \nComments\n example to show how these\nfields work:\n\n\n\n\nA \nUser\n can have a \nlist of Posts\n and a \nlist of Comments\n\n\nA \nPost\n is linked to a single \nUser\n. and can have a \nlist of Comments\n\n\nA \nComment\n is linked to a single \nUser\n and a single \nPost\n\n\n\n\n\nimport {\n    AutoNumberField, TextField, RelatedModel, RelatedModelList,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\nexport class User {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        username: string;\n    @RelatedModelList({ model: 'Post', field: 'user' })\n        posts: Post[];\n    @RelatedModelList({ model: 'Comment', field: 'user' })\n        comments: Comment[];\n\n    constructor(data?: Partial<User>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'User' })\n        user: User;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @RelatedModelList({ model: 'Comment', field: 'post' })\n        comments: Comment[];\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Comment {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'Post' })\n        post: Post;\n    @RelatedModel({ model: 'User', required: false })\n        user: User;\n    @TextField()\n        comment: string;\n\n    constructor(data?: Partial<Comment>) {\n        Object.assign(this, data);\n    }\n}\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(User);\nmodelManager.register(Post);\nmodelManager.register(Comment);\n\n\n\n\nCreating Related Model Data\n\u00b6\n\n\nAs with most RevJS operations, you can create relationships between models\nsimply by assigning values to JavaScript objects as you normally would, then\npassing the resulting object to the\n\ncreate()\n or\n\nupdate()\n methods of\nyour \nModelManager\n.\n\n\nThe below example shows how to create a set of related Users, Posts and\nComments:\n\n\n\nimport { User, Post, Comment, modelManager } from './creating_related_models';\n\nexport async function createData() {\n\n    // Create Users\n\n    const joe = (await modelManager.create(new User({\n        username: 'joe123'\n    }))).result;\n\n    const bill = (await modelManager.create(new User({\n        username: 'bill27'\n    }))).result;\n\n    const jane = (await modelManager.create(new User({\n        username: 'jane12'\n    }))).result;\n\n    // Create Posts\n\n    const post1 = (await modelManager.create(new Post({\n        title: 'Related Data in RevJS',\n        body: 'Pretty easy to do eh?',\n        user: jane\n    }))).result;\n\n    await modelManager.create(new Post({\n        title: 'The Rain in Spain',\n        body: 'Really is a pain?',\n        user: jane\n    }));\n\n    // Create Comments\n\n    await modelManager.create(new Comment({\n        comment: 'True!',\n        post: post1,\n        user: bill\n    }));\n\n    await modelManager.create(new Comment({\n        comment: 'Hmmm, but I reeeeaally like writing SQL...',\n        post: post1,\n        user: joe\n    }));\n\n\n\n\n\n\nReading Related Model Data\n\u00b6\n\n\nBy default, RevJS will NOT return related model information (for performance\nreasons). However, it is easy to request this data using the \nrelated\n option\nfor the\n\nModelManager.read()\n method.\n\n\nSee below examples for how to read related model data:\n\n\n\nimport { Post, modelManager } from './creating_related_models';\nimport { createData } from './creating_related_data';\n\n(async () => {\n    await createData();\n\n    // Read all posts (without related data)\n    const plainPosts = await modelManager.read(Post);\n    console.log('Plain posts:', plainPosts.results);\n\n    // Read all posts, including the 'user' field\n    const posts2 = await modelManager.read(Post, {\n        related: ['user']\n    });\n    console.log('Posts with User:', posts2.results);\n\n    // Read all posts, including the 'user' and 'comments'\n    const posts3 = await modelManager.read(Post, {\n        related: ['user', 'comments']\n    });\n    console.log('Posts with User and Comments:', posts3.results);\n\n    // Read all posts, including the 'user', 'comments' and 'comments.user'\n    const posts4 = await modelManager.read(Post, {\n        related: ['user', 'comments.user']\n    });\n    console.log('Posts with User, Comments and Comment Author:', posts4.results);\n\n})()\n\n\n\n\nUpdating Related Model Records\n\u00b6\n\n\nYou can change the record linked to a RevJS model simply by attaching a\ndifferent model instance, or setting the value to \nnull\n, as shown in the\nexamples below:\n\n\n\nimport { User, Post, Comment, modelManager } from './creating_related_models';\nimport { createData } from './creating_related_data';\n\n(async () => {\n    await createData();\n\n    // Get the first post\n    const post1 = (await modelManager.read(Post, { limit: 1 })).results[0];\n\n    // Get the first user\n    const user1 = (await modelManager.read(User, { limit: 1 })).results[0];\n\n    // Make user1 the author of post1\n    post1.user = user1;\n    await modelManager.update(post1);\n\n    // If we know the ID of the record we want to link, we can pass a new\n    // model instance containing the related ID:\n    post1.user = new User({ id: 2 });\n    await modelManager.update(post1);\n\n    // To un-link a model, set the RelatedModel field to null\n    const comment1 = (await modelManager.read(Comment, { limit: 1 })).results[0];\n    comment1.user = null;\n    await modelManager.update(comment1);\n\n})()\n\n\n\n\nNOTE:\n - RevJS supports assigning values to \nRelatedModel\n fields \nonly\n at\nthe moment. Changes to RelatedModelList fields do not get stored\ncurrently.\n\n\nSearching based on Related Model Data\n\u00b6\n\n\nRevJS allows you to search records based on the Primary Key values stored in\nRelatedModel fields. For example:\n\n\n// Retrieve all comments linked to User id = 1\nmodelManager.read(Comment, {\n    where: {\n        user: 1\n    }\n})\n\n// Retrieve all comments that are not linked to a user\nmodelManager.read(Comment, {\n    where: {\n        user: null\n    }\n})\n\n\n\n\nRevJS does \nnot yet\n support querying for records based on properties of related\nrecords. For example, the following is \nnot yet possible\n, but would be cool:\n\n\nmodelManager.read(User, {\n    where: {\n        'posts.title': { _like: '%fake news%' }\n    }\n})\n\n\n\n\nWe hope to implement something like this in the future, and of course welcome\ncontributions from the community! :)",
            "title": "Working with Related Models"
        },
        {
            "location": "/using_models/related_data/#working-with-related-models",
            "text": "To fully model your data, you will normally want to define relationships\nbetween your models.  For example, you might want to associate a  Post  model with a  User  (the\nauthor), and also your  Post  model may have many  Comments  linked with it.",
            "title": "Working with Related Models"
        },
        {
            "location": "/using_models/related_data/#defining-relationships",
            "text": "RevJS currently has two types of relational fields:   A  RelatedModel  field is a\n  link from the current model to  one record from another model . In the\n   Post  example above, you would add a  @RelatedModel()  field for the\n   user  field.  A  RelatedModelList \n  field allows access to  a list of records from another model , that are\n  linked to the current one via a RelatedModel field. In the  Post  example\n  above, you would add a  @RelatedModelList()  field for the  comments  field.   Lets implement the  Post ,  User ,  Comments  example to show how these\nfields work:   A  User  can have a  list of Posts  and a  list of Comments  A  Post  is linked to a single  User . and can have a  list of Comments  A  Comment  is linked to a single  User  and a single  Post   \nimport {\n    AutoNumberField, TextField, RelatedModel, RelatedModelList,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\nexport class User {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        username: string;\n    @RelatedModelList({ model: 'Post', field: 'user' })\n        posts: Post[];\n    @RelatedModelList({ model: 'Comment', field: 'user' })\n        comments: Comment[];\n\n    constructor(data?: Partial<User>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'User' })\n        user: User;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @RelatedModelList({ model: 'Comment', field: 'post' })\n        comments: Comment[];\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Comment {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'Post' })\n        post: Post;\n    @RelatedModel({ model: 'User', required: false })\n        user: User;\n    @TextField()\n        comment: string;\n\n    constructor(data?: Partial<Comment>) {\n        Object.assign(this, data);\n    }\n}\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(User);\nmodelManager.register(Post);\nmodelManager.register(Comment);",
            "title": "Defining Relationships"
        },
        {
            "location": "/using_models/related_data/#creating-related-model-data",
            "text": "As with most RevJS operations, you can create relationships between models\nsimply by assigning values to JavaScript objects as you normally would, then\npassing the resulting object to the create()  or update()  methods of\nyour  ModelManager .  The below example shows how to create a set of related Users, Posts and\nComments:  \nimport { User, Post, Comment, modelManager } from './creating_related_models';\n\nexport async function createData() {\n\n    // Create Users\n\n    const joe = (await modelManager.create(new User({\n        username: 'joe123'\n    }))).result;\n\n    const bill = (await modelManager.create(new User({\n        username: 'bill27'\n    }))).result;\n\n    const jane = (await modelManager.create(new User({\n        username: 'jane12'\n    }))).result;\n\n    // Create Posts\n\n    const post1 = (await modelManager.create(new Post({\n        title: 'Related Data in RevJS',\n        body: 'Pretty easy to do eh?',\n        user: jane\n    }))).result;\n\n    await modelManager.create(new Post({\n        title: 'The Rain in Spain',\n        body: 'Really is a pain?',\n        user: jane\n    }));\n\n    // Create Comments\n\n    await modelManager.create(new Comment({\n        comment: 'True!',\n        post: post1,\n        user: bill\n    }));\n\n    await modelManager.create(new Comment({\n        comment: 'Hmmm, but I reeeeaally like writing SQL...',\n        post: post1,\n        user: joe\n    }));",
            "title": "Creating Related Model Data"
        },
        {
            "location": "/using_models/related_data/#reading-related-model-data",
            "text": "By default, RevJS will NOT return related model information (for performance\nreasons). However, it is easy to request this data using the  related  option\nfor the ModelManager.read()  method.  See below examples for how to read related model data:  \nimport { Post, modelManager } from './creating_related_models';\nimport { createData } from './creating_related_data';\n\n(async () => {\n    await createData();\n\n    // Read all posts (without related data)\n    const plainPosts = await modelManager.read(Post);\n    console.log('Plain posts:', plainPosts.results);\n\n    // Read all posts, including the 'user' field\n    const posts2 = await modelManager.read(Post, {\n        related: ['user']\n    });\n    console.log('Posts with User:', posts2.results);\n\n    // Read all posts, including the 'user' and 'comments'\n    const posts3 = await modelManager.read(Post, {\n        related: ['user', 'comments']\n    });\n    console.log('Posts with User and Comments:', posts3.results);\n\n    // Read all posts, including the 'user', 'comments' and 'comments.user'\n    const posts4 = await modelManager.read(Post, {\n        related: ['user', 'comments.user']\n    });\n    console.log('Posts with User, Comments and Comment Author:', posts4.results);\n\n})()",
            "title": "Reading Related Model Data"
        },
        {
            "location": "/using_models/related_data/#updating-related-model-records",
            "text": "You can change the record linked to a RevJS model simply by attaching a\ndifferent model instance, or setting the value to  null , as shown in the\nexamples below:  \nimport { User, Post, Comment, modelManager } from './creating_related_models';\nimport { createData } from './creating_related_data';\n\n(async () => {\n    await createData();\n\n    // Get the first post\n    const post1 = (await modelManager.read(Post, { limit: 1 })).results[0];\n\n    // Get the first user\n    const user1 = (await modelManager.read(User, { limit: 1 })).results[0];\n\n    // Make user1 the author of post1\n    post1.user = user1;\n    await modelManager.update(post1);\n\n    // If we know the ID of the record we want to link, we can pass a new\n    // model instance containing the related ID:\n    post1.user = new User({ id: 2 });\n    await modelManager.update(post1);\n\n    // To un-link a model, set the RelatedModel field to null\n    const comment1 = (await modelManager.read(Comment, { limit: 1 })).results[0];\n    comment1.user = null;\n    await modelManager.update(comment1);\n\n})()  NOTE:  - RevJS supports assigning values to  RelatedModel  fields  only  at\nthe moment. Changes to RelatedModelList fields do not get stored\ncurrently.",
            "title": "Updating Related Model Records"
        },
        {
            "location": "/using_models/related_data/#searching-based-on-related-model-data",
            "text": "RevJS allows you to search records based on the Primary Key values stored in\nRelatedModel fields. For example:  // Retrieve all comments linked to User id = 1\nmodelManager.read(Comment, {\n    where: {\n        user: 1\n    }\n})\n\n// Retrieve all comments that are not linked to a user\nmodelManager.read(Comment, {\n    where: {\n        user: null\n    }\n})  RevJS does  not yet  support querying for records based on properties of related\nrecords. For example, the following is  not yet possible , but would be cool:  modelManager.read(User, {\n    where: {\n        'posts.title': { _like: '%fake news%' }\n    }\n})  We hope to implement something like this in the future, and of course welcome\ncontributions from the community! :)",
            "title": "Searching based on Related Model Data"
        },
        {
            "location": "/creating_an_api/overview/",
            "text": "Creating a GraphQL API\n\u00b6\n\n\nThe \nrev-api\n module of RevJS allows you to easily make your models available\nover the network, via an automatically-generated GraphQL API.\n\n\n\n\nModels are exposed via the \nModelApiManager.register()\n method, and you can\n  choose to expose all of your models via the API, or just a subset of them.\n\n\nYou can choose which \noperations\n (create, read, update, remove) to allow\n  on your models via the API.\n\n\nYou can also expose some of your \nmodel methods\n as \nGraphQL mutations\n.\n\n\n\n\nRegistering API Models\n\u00b6\n\n\nThe example below shows how to specify the allowed operations for specific\nmodels, and register them with an API:\n\n\n\nimport {\n    AutoNumberField, TextField, RelatedModel, RelatedModelList,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\nimport { ApiOperations } from 'rev-api/lib/decorators';\nimport { ModelApiManager } from 'rev-api';\n\n// Use the @ApiOperations decorator to specify what operations are allowed for each model\n\n@ApiOperations(\n    ['read']\n)\nexport class User {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        username: string;\n    @RelatedModelList({ model: 'Post', field: 'user' })\n        posts: Post[];\n    @RelatedModelList({ model: 'Comment', field: 'user' })\n        comments: Comment[];\n\n    constructor(data?: Partial<User>) {\n        Object.assign(this, data);\n    }\n}\n\n@ApiOperations(\n    ['create', 'read', 'update', 'remove']\n)\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'User' })\n        user: User;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @RelatedModelList({ model: 'Comment', field: 'post' })\n        comments: Comment[];\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n@ApiOperations(\n    ['create', 'read', 'remove']\n)\nexport class Comment {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'Post' })\n        post: Post;\n    @RelatedModel({ model: 'User', required: false })\n        user: User;\n    @TextField()\n        comment: string;\n\n    constructor(data?: Partial<Comment>) {\n        Object.assign(this, data);\n    }\n}\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(User);\nmodelManager.register(Post);\nmodelManager.register(Comment);\n\nexport const api = new ModelApiManager(modelManager);\napi.register(User);\napi.register(Post);\napi.register(Comment)\n\n\n\n\nNOTE:\n The seperate import from \nrev-api/lib/decorators\n is designed so you\ncan share the same model definition between your front and back-end code,\nwithout inadvertently including \nrev-api\n back-end code in your front-end\nbundle.\n\n\nExposing your API via HTTP\n\u00b6\n\n\nAPIs created via \nrev-api\n can be exposed by any web framework that can\nserve \nGraphQL JS\n schemas. A good\nexample is \nApollo GraphQL Server\n\nwhich supports most popular NodeJS Web Frameworks.\n\n\nIn the example below, we use apollo graphql server to serve our API:\n\n\n\nimport * as koa from 'koa';\nimport * as koaRouter from 'koa-router';\nimport * as koaBody from 'koa-bodyparser';\nimport { graphqlKoa, graphiqlKoa } from 'graphql-server-koa';\n\n// Load RevJS API and generate GrapQL Schema\n\nimport { api } from './defining_an_api';\nimport { createData } from './model_data';\n\nconst schema = api.getGraphQLSchema();\n\n// Create Koa & Apollo GraphQL Server\n\nconst app = new koa();\nconst port = 3000;\n\nconst router = new koaRouter();\nrouter.post('/graphql', graphqlKoa({ schema: schema }));\nrouter.get('/graphql', graphqlKoa({ schema: schema }));\nrouter.get('/graphiql', graphiqlKoa({ endpointURL: '/graphql' }));\n\napp.use(koaBody());\napp.use(router.routes());\napp.use(router.allowedMethods());\n\napp.listen(port);\n\nconsole.log(`GraphQL Server is running on port ${port}.`);\nconsole.log(`GraphiQL UI is running at http://localhost:${port}/graphiql`);\n\n// Load sample data\n\ncreateData()\n.then(() => {\n    console.log('Data Loaded.');\n})\n.catch((e) => {\n    console.error('Error loading data', e);\n})\n\n\n\n\nGraphQL Query Schema\n\u00b6\n\n\nThe GraphQL \nquery {}\n schema lets you read models and fields in a hierarchical\nway.\n\n\n\n\nRevJS generates a top-level Query object for each model you expose for\n  \nread\n access\n\n\nYou can use the standard \nread()\n function options (\nwhere\n, \nlimit\n,\n \noffset\n and \norderBy\n) when querying the top-level Query objects\n\n\nQuery objects contain a \nresults\n key, containing the matching models, and\n  a \nmeta\n key, containing the current \nlimit\n, \noffset\n and \ntotalCount\n values.\n\n\nRevJS respects the \nRelatedModel\n and \nRelatedModelList\n fields you define\n  on your models, and you can drill-down on these fields to any level in your\n  GraphQL query.\n\n\n\n\nThe screenshot below shows the GraphQL Query Schema generated from the examples\nabove:\n\n\n\n\nGraphQL Mutation Schema\n\u00b6\n\n\nThe GraphQL \nmutation {}\n schema provides access to \ncreate()\n, \nupdate()\n and\n\nremove()\n functions, for all models you have enabled these for. Any\ncustom API Methods you have created will also be available here.\n\n\nThe screenshot below shows the GraphQL Mutation Schema generated from the\nexamples above:\n\n\n\n\nSecurity\n\u00b6\n\n\nIt is \nvery\n important to consider security when exposing data via an API.\nCurrently you must implement security policies in your models, and at the Web\nServer layer (e.g. by securiing your API with\n\nPassport\n).\n\n\nIn future releases we may implement support for \nmiddleware\n, which could be used\nfor authentication and authorisation, but currently we do not have support for\nthis. Contributions welcome! :)",
            "title": "Creating an API"
        },
        {
            "location": "/creating_an_api/overview/#creating-a-graphql-api",
            "text": "The  rev-api  module of RevJS allows you to easily make your models available\nover the network, via an automatically-generated GraphQL API.   Models are exposed via the  ModelApiManager.register()  method, and you can\n  choose to expose all of your models via the API, or just a subset of them.  You can choose which  operations  (create, read, update, remove) to allow\n  on your models via the API.  You can also expose some of your  model methods  as  GraphQL mutations .",
            "title": "Creating a GraphQL API"
        },
        {
            "location": "/creating_an_api/overview/#registering-api-models",
            "text": "The example below shows how to specify the allowed operations for specific\nmodels, and register them with an API:  \nimport {\n    AutoNumberField, TextField, RelatedModel, RelatedModelList,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\nimport { ApiOperations } from 'rev-api/lib/decorators';\nimport { ModelApiManager } from 'rev-api';\n\n// Use the @ApiOperations decorator to specify what operations are allowed for each model\n\n@ApiOperations(\n    ['read']\n)\nexport class User {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        username: string;\n    @RelatedModelList({ model: 'Post', field: 'user' })\n        posts: Post[];\n    @RelatedModelList({ model: 'Comment', field: 'user' })\n        comments: Comment[];\n\n    constructor(data?: Partial<User>) {\n        Object.assign(this, data);\n    }\n}\n\n@ApiOperations(\n    ['create', 'read', 'update', 'remove']\n)\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'User' })\n        user: User;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @RelatedModelList({ model: 'Comment', field: 'post' })\n        comments: Comment[];\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n@ApiOperations(\n    ['create', 'read', 'remove']\n)\nexport class Comment {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'Post' })\n        post: Post;\n    @RelatedModel({ model: 'User', required: false })\n        user: User;\n    @TextField()\n        comment: string;\n\n    constructor(data?: Partial<Comment>) {\n        Object.assign(this, data);\n    }\n}\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(User);\nmodelManager.register(Post);\nmodelManager.register(Comment);\n\nexport const api = new ModelApiManager(modelManager);\napi.register(User);\napi.register(Post);\napi.register(Comment)  NOTE:  The seperate import from  rev-api/lib/decorators  is designed so you\ncan share the same model definition between your front and back-end code,\nwithout inadvertently including  rev-api  back-end code in your front-end\nbundle.",
            "title": "Registering API Models"
        },
        {
            "location": "/creating_an_api/overview/#exposing-your-api-via-http",
            "text": "APIs created via  rev-api  can be exposed by any web framework that can\nserve  GraphQL JS  schemas. A good\nexample is  Apollo GraphQL Server \nwhich supports most popular NodeJS Web Frameworks.  In the example below, we use apollo graphql server to serve our API:  \nimport * as koa from 'koa';\nimport * as koaRouter from 'koa-router';\nimport * as koaBody from 'koa-bodyparser';\nimport { graphqlKoa, graphiqlKoa } from 'graphql-server-koa';\n\n// Load RevJS API and generate GrapQL Schema\n\nimport { api } from './defining_an_api';\nimport { createData } from './model_data';\n\nconst schema = api.getGraphQLSchema();\n\n// Create Koa & Apollo GraphQL Server\n\nconst app = new koa();\nconst port = 3000;\n\nconst router = new koaRouter();\nrouter.post('/graphql', graphqlKoa({ schema: schema }));\nrouter.get('/graphql', graphqlKoa({ schema: schema }));\nrouter.get('/graphiql', graphiqlKoa({ endpointURL: '/graphql' }));\n\napp.use(koaBody());\napp.use(router.routes());\napp.use(router.allowedMethods());\n\napp.listen(port);\n\nconsole.log(`GraphQL Server is running on port ${port}.`);\nconsole.log(`GraphiQL UI is running at http://localhost:${port}/graphiql`);\n\n// Load sample data\n\ncreateData()\n.then(() => {\n    console.log('Data Loaded.');\n})\n.catch((e) => {\n    console.error('Error loading data', e);\n})",
            "title": "Exposing your API via HTTP"
        },
        {
            "location": "/creating_an_api/overview/#graphql-query-schema",
            "text": "The GraphQL  query {}  schema lets you read models and fields in a hierarchical\nway.   RevJS generates a top-level Query object for each model you expose for\n   read  access  You can use the standard  read()  function options ( where ,  limit ,\n  offset  and  orderBy ) when querying the top-level Query objects  Query objects contain a  results  key, containing the matching models, and\n  a  meta  key, containing the current  limit ,  offset  and  totalCount  values.  RevJS respects the  RelatedModel  and  RelatedModelList  fields you define\n  on your models, and you can drill-down on these fields to any level in your\n  GraphQL query.   The screenshot below shows the GraphQL Query Schema generated from the examples\nabove:",
            "title": "GraphQL Query Schema"
        },
        {
            "location": "/creating_an_api/overview/#graphql-mutation-schema",
            "text": "The GraphQL  mutation {}  schema provides access to  create() ,  update()  and remove()  functions, for all models you have enabled these for. Any\ncustom API Methods you have created will also be available here.  The screenshot below shows the GraphQL Mutation Schema generated from the\nexamples above:",
            "title": "GraphQL Mutation Schema"
        },
        {
            "location": "/creating_an_api/overview/#security",
            "text": "It is  very  important to consider security when exposing data via an API.\nCurrently you must implement security policies in your models, and at the Web\nServer layer (e.g. by securiing your API with Passport ).  In future releases we may implement support for  middleware , which could be used\nfor authentication and authorisation, but currently we do not have support for\nthis. Contributions welcome! :)",
            "title": "Security"
        },
        {
            "location": "/creating_a_ui/overview/",
            "text": "Building a UI with RevJS\n\u00b6\n\n\nThe \nrev-ui\n module of RevJS provides a number of React components designed to\nhelp you quickly build data-driven user interfaces. We have provided a set of\nMaterial UI components (in the \nrev-ui-materialui\n module), however \nrev-ui\n\nis designed to be used with \nany UI components\n, including your own.\n\n\nWhen combined with \nrev-api-client\n, you can render data from your API with\na very minimal amount of front-end code. Check out the\n\nListView example\n and the\n\nDetailView example\n.\n\n\n\n\nRevJS UI Components\n\u00b6\n\n\nRevJS provides the follwing basic components, as building blocks for your data\ndriven application. The rendering of each of these can be completely customised\nvia the \ncomponent\n property of each, or globally via the\n\nUI_COMPONENTS\n configuration setting.\n\n\nViews\n\n\n\n\n<ListView />\n - Loads and\n  renders a list of records, including \nfiltering\n, \nsorting\n and\n  \npagination\n.\n\n\n<SearchView />\n - Combine\n  this with a ListView to allow \nuser-defined searching\n.\n\n\n<DetailView />\n - Loads\n  a single record, and provides functions for \nvalidating\n, \nsaving\n\n  and \nremoving\n it.\n\n\n\n\nActions\n\n\nThe following components can be placed inside a \n<DetailView />\n, to trigger\nthe corresponding action.\n\n\n\n\n<SaveAction />\n - Validate\n  and save the curremt record.\n\n\n<RemoveAction />\n -\n  Remove the current record.\n\n\n<PostAction />\n - Validate\n  the current record, then send the data as JSON to any HTTP endpoint.\n\n\n\n\nFields\n\n\nThe following components can be placed inside a \n<DetailView />\n, to allow\nthe user to edit the model data.\n\n\n\n\n<Field />\n - Displays an\n  appropriate input control, depending on the type of the field specified.\n  Also displays any field-level validation errors when they occur.\n\n\n\n\nProvider\n\n\n\n\n<ModelProvider />\n -\n  A React Provider that gives its sub-components access to models from the\n  specified RevJS ModelManager.\n\n\n\n\nThe following sections give some complete examples of how to make use of the\nabove components.",
            "title": "RevJS UI Overview"
        },
        {
            "location": "/creating_a_ui/overview/#building-a-ui-with-revjs",
            "text": "The  rev-ui  module of RevJS provides a number of React components designed to\nhelp you quickly build data-driven user interfaces. We have provided a set of\nMaterial UI components (in the  rev-ui-materialui  module), however  rev-ui \nis designed to be used with  any UI components , including your own.  When combined with  rev-api-client , you can render data from your API with\na very minimal amount of front-end code. Check out the ListView example  and the DetailView example .",
            "title": "Building a UI with RevJS"
        },
        {
            "location": "/creating_a_ui/overview/#revjs-ui-components",
            "text": "RevJS provides the follwing basic components, as building blocks for your data\ndriven application. The rendering of each of these can be completely customised\nvia the  component  property of each, or globally via the UI_COMPONENTS  configuration setting.  Views   <ListView />  - Loads and\n  renders a list of records, including  filtering ,  sorting  and\n   pagination .  <SearchView />  - Combine\n  this with a ListView to allow  user-defined searching .  <DetailView />  - Loads\n  a single record, and provides functions for  validating ,  saving \n  and  removing  it.   Actions  The following components can be placed inside a  <DetailView /> , to trigger\nthe corresponding action.   <SaveAction />  - Validate\n  and save the curremt record.  <RemoveAction />  -\n  Remove the current record.  <PostAction />  - Validate\n  the current record, then send the data as JSON to any HTTP endpoint.   Fields  The following components can be placed inside a  <DetailView /> , to allow\nthe user to edit the model data.   <Field />  - Displays an\n  appropriate input control, depending on the type of the field specified.\n  Also displays any field-level validation errors when they occur.   Provider   <ModelProvider />  -\n  A React Provider that gives its sub-components access to models from the\n  specified RevJS ModelManager.   The following sections give some complete examples of how to make use of the\nabove components.",
            "title": "RevJS UI Components"
        },
        {
            "location": "/creating_a_ui/simple_list/",
            "text": "Rendering a Simple ListView\n\u00b6\n\n\nBy default, a \n<ListView />\n\nwill render a table, as shown in the screenshot below:\n\n\n\n\nThe data starts loading as soon as the ListView is rendered. A Loading\nindicator is shown until the data has finished loading. Once the data is loaded,\nthe user can use the forward and back buttons to page through the data.\n\n\nJSX for a Simple List\n\u00b6\n\n\nThe following JSX code will render the list shown above:\n\n\n<ModelProvider modelManager={modelManager} >\n    <ListView\n        title=\"Current Posts\"\n        model=\"Post\"\n        fields={[\n            'post_date',\n            'title',\n            'description',\n        ]}\n        where={{\n            post_date: { _gt: '2017-01-01' }\n        }}\n        orderBy={['post_date desc']}\n        limit={5}\n    />\n</ModelProvider>\n\n\n\n\n(Complete working example\n\nhere\n).\n\n\nYou can use the \nfields\n prop of the ListView to select which columns to\nshow, and the \nwhere\n, \norderBy\n and \nlimit\n props to control the data shown.\n\n\nIn the next example, we'll look at how to render your own list view components.",
            "title": "Simple ListView"
        },
        {
            "location": "/creating_a_ui/simple_list/#rendering-a-simple-listview",
            "text": "By default, a  <ListView /> \nwill render a table, as shown in the screenshot below:   The data starts loading as soon as the ListView is rendered. A Loading\nindicator is shown until the data has finished loading. Once the data is loaded,\nthe user can use the forward and back buttons to page through the data.",
            "title": "Rendering a Simple ListView"
        },
        {
            "location": "/creating_a_ui/simple_list/#jsx-for-a-simple-list",
            "text": "The following JSX code will render the list shown above:  <ModelProvider modelManager={modelManager} >\n    <ListView\n        title=\"Current Posts\"\n        model=\"Post\"\n        fields={[\n            'post_date',\n            'title',\n            'description',\n        ]}\n        where={{\n            post_date: { _gt: '2017-01-01' }\n        }}\n        orderBy={['post_date desc']}\n        limit={5}\n    />\n</ModelProvider>  (Complete working example here ).  You can use the  fields  prop of the ListView to select which columns to\nshow, and the  where ,  orderBy  and  limit  props to control the data shown.  In the next example, we'll look at how to render your own list view components.",
            "title": "JSX for a Simple List"
        },
        {
            "location": "/creating_a_ui/custom_list/",
            "text": "Rendering a Custom ListView\n\u00b6\n\n\nYou can render a list of model data in any way you wish using the \ncomponent\n\nproperty of the \n<ListView />\n\ncomponent. The screenshot below shows the posts from the previous example,\nrendered as a grid of cards instead of a table.\n\n\n\n\nTo create a custom ListView component, you just need to implement a React\ncomponent that accepts \nIListViewComponentProps\n,\nas shown in the example below\n\n\nJSX for a Custom ListView Component\n\u00b6\n\n\nFirst, create a React component that accepts\n\nIListViewComponentProps\n\nand renders the data as needed. We recommend creating a Stateless Functional\nComponent for this, since RevJS handles the loading and data state for you:\n\n\nconst MyCustomListView = (props: IListViewComponentProps<models.Post>) => {\n    if (props.loadState == 'LOADING') {\n        // Loading state\n        return (\n            <Typography variant=\"subheading\">\n                Loading...\n            </Typography>\n        );\n    }\n    else {\n        // Render the posts as a list of cards\n        const postCards = props.results.map((post) => (\n            <Card>\n                <CardHeader\n                    avatar={\n                        <Avatar style={{ backgroundColor: getColour() }}>\n                            {post.title.substr(0, 1)}\n                        </Avatar>\n                    }\n                    title={post.title}\n                    subheader={post.post_date}\n                />\n                <CardContent>\n                    <Typography component=\"p\">\n                        {post.body}\n                    </Typography>\n                </CardContent>\n            </Card>\n        ));\n\n        return (\n            <div>\n                <Typography variant=\"title\">\n                    {props.title}\n                </Typography>\n                <Grid container spacing={40}>\n                    {postCards}\n                </Grid>\n            </div>\n        );\n    }\n};\n\n\n\n\nTo render your custom list component, simply pass it into RevJS's ListView\ncomponent along with the query you want to populate it with. There is obviously\nno need to pass in the \nfields\n prop in this case - all the fields of the \n\nPost\n model will be available for you to render.\n\n\n<ModelProvider modelManager={modelManager} >\n    <ListView\n        title=\"Current Posts\"\n        model=\"Post\"\n        where={{\n            post_date: { _gt: '2017-01-01' }\n        }}\n        orderBy={['post_date desc']}\n        component={MyCustomListView}\n    />\n</ModelProvider>\n\n\n\n\n(Complete working example\n\nhere\n).",
            "title": "Custom ListView"
        },
        {
            "location": "/creating_a_ui/custom_list/#rendering-a-custom-listview",
            "text": "You can render a list of model data in any way you wish using the  component \nproperty of the  <ListView /> \ncomponent. The screenshot below shows the posts from the previous example,\nrendered as a grid of cards instead of a table.   To create a custom ListView component, you just need to implement a React\ncomponent that accepts  IListViewComponentProps ,\nas shown in the example below",
            "title": "Rendering a Custom ListView"
        },
        {
            "location": "/creating_a_ui/custom_list/#jsx-for-a-custom-listview-component",
            "text": "First, create a React component that accepts IListViewComponentProps \nand renders the data as needed. We recommend creating a Stateless Functional\nComponent for this, since RevJS handles the loading and data state for you:  const MyCustomListView = (props: IListViewComponentProps<models.Post>) => {\n    if (props.loadState == 'LOADING') {\n        // Loading state\n        return (\n            <Typography variant=\"subheading\">\n                Loading...\n            </Typography>\n        );\n    }\n    else {\n        // Render the posts as a list of cards\n        const postCards = props.results.map((post) => (\n            <Card>\n                <CardHeader\n                    avatar={\n                        <Avatar style={{ backgroundColor: getColour() }}>\n                            {post.title.substr(0, 1)}\n                        </Avatar>\n                    }\n                    title={post.title}\n                    subheader={post.post_date}\n                />\n                <CardContent>\n                    <Typography component=\"p\">\n                        {post.body}\n                    </Typography>\n                </CardContent>\n            </Card>\n        ));\n\n        return (\n            <div>\n                <Typography variant=\"title\">\n                    {props.title}\n                </Typography>\n                <Grid container spacing={40}>\n                    {postCards}\n                </Grid>\n            </div>\n        );\n    }\n};  To render your custom list component, simply pass it into RevJS's ListView\ncomponent along with the query you want to populate it with. There is obviously\nno need to pass in the  fields  prop in this case - all the fields of the  Post  model will be available for you to render.  <ModelProvider modelManager={modelManager} >\n    <ListView\n        title=\"Current Posts\"\n        model=\"Post\"\n        where={{\n            post_date: { _gt: '2017-01-01' }\n        }}\n        orderBy={['post_date desc']}\n        component={MyCustomListView}\n    />\n</ModelProvider>  (Complete working example here ).",
            "title": "JSX for a Custom ListView Component"
        },
        {
            "location": "/creating_a_ui/related_data/",
            "text": "Showing Related Model Data\n\u00b6\n\n\nOne of the key things about a well structured Data Model is how the models\nare related.\n\n\nIn the classic \nPost\n, \nUser\n, \nComments\n model, a User can be\neither an author of a Post, or of a Comment. If you need to update a User's\nname, ideally you don't want to have to go through all the Posts and Comments\nupdating the name, instead you should update just the User object, and \nhave a \"Link\" between Posts and Comments, and the User.\n\n\nIn RevJS, this is achieved with \nRelatedModel\n fields (see\n\nWorking with Related Models\n).\n\n\nOnce you have these relationships defined, you'll probably want to be able to\ndisplay this related information to the user. The following sections\ndescribe a couple of ways this can be done.\n\n\nShowing RelatedModel fields\n\u00b6\n\n\nIn the example above, we mentioned that a User can be an Author of a Post.\n\n\nIn our Post model, this is modelled as shown below:\n\n\nexport class Post {\n    @RelatedModel({ label: 'Author', model: 'User' })\n        user: User;\n    ...\n}\n\n\n\n\nIf we just include the \nuser\n field in our ListView fields, it will\nappear as shown in the screenshot below:\n\n\n\n\nYou may notice that \"[object Object]\" is the standard result of calling\n\ntoString()\n on a JavaScript object. So, to have the Author name displayed,\nwe just need to override the \ntoString()\n method on the \nUser\n model:\n\n\nexport class User {\n    ...\n\n    toString() {\n        return this.first_name + ' ' + this.last_name;\n    }\n}\n\n\n\n\nThis will result in the user's name being shown, which is what we want:\n\n\n\n\nUsing JavaScript Getters\n\u00b6\n\n\nThere may be situations where just defining a toString() method on a model is\nnot flexible enough, for example if you want a User's details to be displayed\ndifferently in different situations, or if the value you want to show is based\non data from multiple models.\n\n\nIn these situations you can a\n\nJavaScript Getter\n\nfunction.\n\n\nIn the example below, we define a Getter on our Post object which returns\nthe number of Comments:\n\n\nclass Post {\n    ...\n    @IntegerField({ label: 'No. of Comments' })\n        get number_of_comments() {\n            return (this.comments && this.comments.length) || 0;\n        }\n}\n\n\n\n\n(Note: this requires retrieval of all the comments, so don't do this in\nproduction!)\n\n\nOnce the getter is defined as a field, you can then add \nnumber_of_comments\n to\nthe \nfields\n list of your ListView, and it will be displayed as shown below:\n\n\n\n\nReading Related Models in ListViews\n\u00b6\n\n\nBy default, when a \n<ListView />\n\nfetches data, it will fetch fields from the \nspecified model only\n.\n\n\nIf you wish to fetch related model data, you will need to specify the \nrelated\n\nproperty.\n\n\nIn the example below, we retrieve Posts along with their Author and Comments:\n\n\n<ModelProvider modelManager={modelManager} >\n    <ListView\n        title=\"Current Posts\"\n        model=\"Post\"\n        fields={[\n            'post_date',\n            'title',\n            'description',\n            'user',\n            'number_of_comments',\n        ]}\n        related={[\n            'user',\n            'comments'\n        ]}\n        where={{\n            post_date: { _gt: '2017-01-01' }\n        }}\n        orderBy={['post_date desc']}\n        limit={5}\n    />\n</ModelProvider>\n\n\n\n\n(Complete working example\n\nhere\n).",
            "title": "Listing Related Model Data"
        },
        {
            "location": "/creating_a_ui/related_data/#showing-related-model-data",
            "text": "One of the key things about a well structured Data Model is how the models\nare related.  In the classic  Post ,  User ,  Comments  model, a User can be\neither an author of a Post, or of a Comment. If you need to update a User's\nname, ideally you don't want to have to go through all the Posts and Comments\nupdating the name, instead you should update just the User object, and \nhave a \"Link\" between Posts and Comments, and the User.  In RevJS, this is achieved with  RelatedModel  fields (see Working with Related Models ).  Once you have these relationships defined, you'll probably want to be able to\ndisplay this related information to the user. The following sections\ndescribe a couple of ways this can be done.",
            "title": "Showing Related Model Data"
        },
        {
            "location": "/creating_a_ui/related_data/#showing-relatedmodel-fields",
            "text": "In the example above, we mentioned that a User can be an Author of a Post.  In our Post model, this is modelled as shown below:  export class Post {\n    @RelatedModel({ label: 'Author', model: 'User' })\n        user: User;\n    ...\n}  If we just include the  user  field in our ListView fields, it will\nappear as shown in the screenshot below:   You may notice that \"[object Object]\" is the standard result of calling toString()  on a JavaScript object. So, to have the Author name displayed,\nwe just need to override the  toString()  method on the  User  model:  export class User {\n    ...\n\n    toString() {\n        return this.first_name + ' ' + this.last_name;\n    }\n}  This will result in the user's name being shown, which is what we want:",
            "title": "Showing RelatedModel fields"
        },
        {
            "location": "/creating_a_ui/related_data/#using-javascript-getters",
            "text": "There may be situations where just defining a toString() method on a model is\nnot flexible enough, for example if you want a User's details to be displayed\ndifferently in different situations, or if the value you want to show is based\non data from multiple models.  In these situations you can a JavaScript Getter \nfunction.  In the example below, we define a Getter on our Post object which returns\nthe number of Comments:  class Post {\n    ...\n    @IntegerField({ label: 'No. of Comments' })\n        get number_of_comments() {\n            return (this.comments && this.comments.length) || 0;\n        }\n}  (Note: this requires retrieval of all the comments, so don't do this in\nproduction!)  Once the getter is defined as a field, you can then add  number_of_comments  to\nthe  fields  list of your ListView, and it will be displayed as shown below:",
            "title": "Using JavaScript Getters"
        },
        {
            "location": "/creating_a_ui/related_data/#reading-related-models-in-listviews",
            "text": "By default, when a  <ListView /> \nfetches data, it will fetch fields from the  specified model only .  If you wish to fetch related model data, you will need to specify the  related \nproperty.  In the example below, we retrieve Posts along with their Author and Comments:  <ModelProvider modelManager={modelManager} >\n    <ListView\n        title=\"Current Posts\"\n        model=\"Post\"\n        fields={[\n            'post_date',\n            'title',\n            'description',\n            'user',\n            'number_of_comments',\n        ]}\n        related={[\n            'user',\n            'comments'\n        ]}\n        where={{\n            post_date: { _gt: '2017-01-01' }\n        }}\n        orderBy={['post_date desc']}\n        limit={5}\n    />\n</ModelProvider>  (Complete working example here ).",
            "title": "Reading Related Models in ListViews"
        },
        {
            "location": "/creating_a_ui/searchable_list/",
            "text": "Creating a Searchable ListView\n\u00b6\n\n\nTo create a searchable ListView, you need to create a component that wires up a\n\n<SearchView />'s onSearch() Event\n\nto your\n\n<ListView />'s \"where\" prop\n.\n\n\n\n\nSearchable ListView Example\n\u00b6\n\n\nThe following code creates a searchable ListView component:\n\n\ninterface ISearchableListState {\n    where: object;\n}\n\nexport class SearchableList extends React.Component<any, ISearchableListState> {\n\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            where: {}\n        };\n    }\n\n    onSearch(newWhere: object) {\n        this.setState({\n            where: newWhere\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                <Card>\n\n                    <Typography variant=\"title\">Search</Typography>\n\n                    <SearchView\n                        model=\"Post\"\n                        onSearch={(where) => this.onSearch(where)}\n                    >\n                        <SearchField name=\"title\" />\n                        <SearchField name=\"description\" />\n\n                        <SearchAction label=\"Search Posts\" />\n                    </SearchView>\n\n                </Card>\n                <Card>\n\n                    <ListView\n                        title=\"Matching Posts\"\n                        model=\"Post\"\n                        fields={[\n                            'post_date',\n                            'title',\n                            'description',\n                        ]}\n                        where={this.state.where}\n                    />\n\n                </Card>\n            </div>\n        );\n    }\n}\n\n\n\n\nIn the example above we create a new, stateful, \n<SearchableList />\n component.\nThis component's state contains a single item: \nwhere\n, which contains the\nwhere clause that is automatically generated by the RevJS \n<SearchView />\n\ncomponent.\n\n\nWhen the \n<SearchAction />\n is triggered by the user, the \nonSearch()\n event\nis fired, which in-turn updates the state of the \n<SearchableList />\n component.\n\n\nThis then triggers a re-render of the \n<SearchableList />\n component, which then\npasses the updated \nwhere\n clause to the \n<ListView />\n, which triggers it\nto re-fetch the matching data.\n\n\n(Complete working example\n\nhere\n).",
            "title": "Searchable ListView"
        },
        {
            "location": "/creating_a_ui/searchable_list/#creating-a-searchable-listview",
            "text": "To create a searchable ListView, you need to create a component that wires up a <SearchView />'s onSearch() Event \nto your <ListView />'s \"where\" prop .",
            "title": "Creating a Searchable ListView"
        },
        {
            "location": "/creating_a_ui/searchable_list/#searchable-listview-example",
            "text": "The following code creates a searchable ListView component:  interface ISearchableListState {\n    where: object;\n}\n\nexport class SearchableList extends React.Component<any, ISearchableListState> {\n\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            where: {}\n        };\n    }\n\n    onSearch(newWhere: object) {\n        this.setState({\n            where: newWhere\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                <Card>\n\n                    <Typography variant=\"title\">Search</Typography>\n\n                    <SearchView\n                        model=\"Post\"\n                        onSearch={(where) => this.onSearch(where)}\n                    >\n                        <SearchField name=\"title\" />\n                        <SearchField name=\"description\" />\n\n                        <SearchAction label=\"Search Posts\" />\n                    </SearchView>\n\n                </Card>\n                <Card>\n\n                    <ListView\n                        title=\"Matching Posts\"\n                        model=\"Post\"\n                        fields={[\n                            'post_date',\n                            'title',\n                            'description',\n                        ]}\n                        where={this.state.where}\n                    />\n\n                </Card>\n            </div>\n        );\n    }\n}  In the example above we create a new, stateful,  <SearchableList />  component.\nThis component's state contains a single item:  where , which contains the\nwhere clause that is automatically generated by the RevJS  <SearchView /> \ncomponent.  When the  <SearchAction />  is triggered by the user, the  onSearch()  event\nis fired, which in-turn updates the state of the  <SearchableList />  component.  This then triggers a re-render of the  <SearchableList />  component, which then\npasses the updated  where  clause to the  <ListView /> , which triggers it\nto re-fetch the matching data.  (Complete working example here ).",
            "title": "Searchable ListView Example"
        },
        {
            "location": "/creating_a_ui/detail_view/",
            "text": "Creating a DetailView\n\u00b6\n\n\nYou can use a \n<DetailView />\n,\ncombined with\n\n<Field />\ns and a\n\n<SaveAction />\n\nto quickly build a form to allow users to edit model data.\n\n\n\n\nRevJS uses the metadata you have defined on your models to determine the type\nof input to display for each field.\n\n\nWhen the Save button is clicked, the data is validated\nagainst the rules you have defined on your model, and any validation problems\nare displayed to the user, as shown in the example below:\n\n\n\n\nJSX for a \"Create Post\" DetailView\n\u00b6\n\n\nThe following JSX code will render the DetailView shown above:\n\n\n<ModelProvider modelManager={modelManager} >\n\n    <Typography variant=\"display1\">Create Post</Typography>\n\n    <DetailView model=\"Post\">\n        <Field name=\"title\" colspan={12} />\n        <Field name=\"description\" colspan={12} />\n        <Field name=\"body\" colspan={12} />\n        <Field name=\"post_date\" />\n        <Field name=\"user\" />\n\n        <SaveAction label=\"Create Post\" />\n    </DetailView>\n\n</ModelProvider>\n\n\n\n\nTo help with easy field layout, a DetailView defines a 12-column, responsive\ngrid in which your fields are placed. You can use the \ncolspan\n,\n\ncolspanNarrow\n and \ncolspanWide\n properties of the \n<field />\n component to\nspecify how wide each field is, depending on the screen size. The default\ncolspan for fields is 6 on 'normal' and 'wide' screens, and 12 on 'narrow'\nscreens.\n\n\nA DetailView acts on a \nsingle model instance\n. If you don't specify the\n\nprimaryKeyValue\n property for the \n<DetailView />\n then a new record will\nbe created when the SaveAction is triggered.\n\n\nEditing an existing record in a DetailView\n\u00b6\n\n\nEditing an existing record in a DetailView is simply a case of setting the\n\nprimaryKeyValue\n property. In the example below, we grab a post ID from the\nURL to allow it to be edited:\n\n\nconst currentUrl = new URL(window.location.href);\nconst postId = currentUrl.searchParams.get('id');\n\n<ModelProvider modelManager={modelManager}>\n\n    <Typography variant=\"display1\">Edit Post</Typography>\n\n    <DetailView model=\"Post\" primaryKeyValue={postId}>\n        <Field name=\"title\" colspan={12} />\n        <Field name=\"description\" colspan={12} />\n        <Field name=\"body\" colspan={12} />\n        <Field name=\"post_date\" />\n        <Field name=\"user\" />\n\n        <SaveAction label=\"Save Post\" />\n    </DetailView>\n\n</ModelProvider>\n\n\n\n\nIn this case, when the Save button is clicked, the existing record will be\nupdated.\n\n\nThere is a complete working example that demonstrates the above functionality\n\nhere\n.",
            "title": "DetailViews"
        },
        {
            "location": "/creating_a_ui/detail_view/#creating-a-detailview",
            "text": "You can use a  <DetailView /> ,\ncombined with <Field /> s and a <SaveAction /> \nto quickly build a form to allow users to edit model data.   RevJS uses the metadata you have defined on your models to determine the type\nof input to display for each field.  When the Save button is clicked, the data is validated\nagainst the rules you have defined on your model, and any validation problems\nare displayed to the user, as shown in the example below:",
            "title": "Creating a DetailView"
        },
        {
            "location": "/creating_a_ui/detail_view/#jsx-for-a-create-post-detailview",
            "text": "The following JSX code will render the DetailView shown above:  <ModelProvider modelManager={modelManager} >\n\n    <Typography variant=\"display1\">Create Post</Typography>\n\n    <DetailView model=\"Post\">\n        <Field name=\"title\" colspan={12} />\n        <Field name=\"description\" colspan={12} />\n        <Field name=\"body\" colspan={12} />\n        <Field name=\"post_date\" />\n        <Field name=\"user\" />\n\n        <SaveAction label=\"Create Post\" />\n    </DetailView>\n\n</ModelProvider>  To help with easy field layout, a DetailView defines a 12-column, responsive\ngrid in which your fields are placed. You can use the  colspan , colspanNarrow  and  colspanWide  properties of the  <field />  component to\nspecify how wide each field is, depending on the screen size. The default\ncolspan for fields is 6 on 'normal' and 'wide' screens, and 12 on 'narrow'\nscreens.  A DetailView acts on a  single model instance . If you don't specify the primaryKeyValue  property for the  <DetailView />  then a new record will\nbe created when the SaveAction is triggered.",
            "title": "JSX for a \"Create Post\" DetailView"
        },
        {
            "location": "/creating_a_ui/detail_view/#editing-an-existing-record-in-a-detailview",
            "text": "Editing an existing record in a DetailView is simply a case of setting the primaryKeyValue  property. In the example below, we grab a post ID from the\nURL to allow it to be edited:  const currentUrl = new URL(window.location.href);\nconst postId = currentUrl.searchParams.get('id');\n\n<ModelProvider modelManager={modelManager}>\n\n    <Typography variant=\"display1\">Edit Post</Typography>\n\n    <DetailView model=\"Post\" primaryKeyValue={postId}>\n        <Field name=\"title\" colspan={12} />\n        <Field name=\"description\" colspan={12} />\n        <Field name=\"body\" colspan={12} />\n        <Field name=\"post_date\" />\n        <Field name=\"user\" />\n\n        <SaveAction label=\"Save Post\" />\n    </DetailView>\n\n</ModelProvider>  In this case, when the Save button is clicked, the existing record will be\nupdated.  There is a complete working example that demonstrates the above functionality here .",
            "title": "Editing an existing record in a DetailView"
        },
        {
            "location": "/components/rev-models/",
            "text": "rev-models - RevJS Data Models\n\u00b6\n\n\nThe \nrev-models\n module provides the following:\n\n\n\n\nA set of \nBuilt-in Field Types\n for defining your\n   data models\n\n\nA \nModelManager\n object, which holds the list of\n   your registered models, and provides functions for \ncreate\n, \nread\n,\n   \nupdate\n and \ndelete\n.\n\n\nAn \nin-memory\n storage backend, so you can play with RevJS functions without\n   needing to set up a database.\n\n\n\n\nJump to the \nrev-models API Documentation\n\n\nStorage Backends\n\u00b6\n\n\nIn addition to in-memory storage, the following backends are available:\n\n\nThe \nrev-backend-mongodb\n module provides a \nMongoDBBackend\n class which stores\nand retrieves data from a MongoDB No-SQL database. Jump to the\n\nrev-backend-mongodb API Documentation\n.\n\n\nThe \nrev-api-client\n module provides a \nModelApiBackend\n class which stores\nand retrieves data from the GraphQL API generated by \nrev-api\n.\nJump to the \nrev-api-client API Documentation\n.\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-models"
        },
        {
            "location": "/components/rev-models/#rev-models-revjs-data-models",
            "text": "The  rev-models  module provides the following:   A set of  Built-in Field Types  for defining your\n   data models  A  ModelManager  object, which holds the list of\n   your registered models, and provides functions for  create ,  read ,\n    update  and  delete .  An  in-memory  storage backend, so you can play with RevJS functions without\n   needing to set up a database.   Jump to the  rev-models API Documentation",
            "title": "rev-models - RevJS Data Models"
        },
        {
            "location": "/components/rev-models/#storage-backends",
            "text": "In addition to in-memory storage, the following backends are available:  The  rev-backend-mongodb  module provides a  MongoDBBackend  class which stores\nand retrieves data from a MongoDB No-SQL database. Jump to the rev-backend-mongodb API Documentation .  The  rev-api-client  module provides a  ModelApiBackend  class which stores\nand retrieves data from the GraphQL API generated by  rev-api .\nJump to the  rev-api-client API Documentation .",
            "title": "Storage Backends"
        },
        {
            "location": "/components/rev-models/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/components/rev-api/",
            "text": "rev-api - RevJS GraphQL API Generator\n\u00b6\n\n\nThe \nrev-api\n module provides the following:\n\n\n\n\nA \nModelApiManager\n object, for registering your models to be exposed via\n   the GraphQL API\n\n\nAn \n@ApiOperations\n decorator, for annotating your models with the operations\n   that are allowed on them (\nread\n, \ncreate\n, etc.)\n\n\nAn \n@ApiMethod\n decorator, for annotating any model methods that you\n   want to expose as GraphQL mutations.\n\n\n\n\nFor more information, check out \nCreating an API\n\n\nJump to the \nrev-api API Documentation\n\n\nExample\n\u00b6\n\n\nThe example below creates a few models and assigns them to a ModelApiManager.\n\n\n\nimport {\n    AutoNumberField, TextField, RelatedModel, RelatedModelList,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\nimport { ApiOperations } from 'rev-api/lib/decorators';\nimport { ModelApiManager } from 'rev-api';\n\n// Use the @ApiOperations decorator to specify what operations are allowed for each model\n\n@ApiOperations(\n    ['read']\n)\nexport class User {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        username: string;\n    @RelatedModelList({ model: 'Post', field: 'user' })\n        posts: Post[];\n    @RelatedModelList({ model: 'Comment', field: 'user' })\n        comments: Comment[];\n\n    constructor(data?: Partial<User>) {\n        Object.assign(this, data);\n    }\n}\n\n@ApiOperations(\n    ['create', 'read', 'update', 'remove']\n)\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'User' })\n        user: User;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @RelatedModelList({ model: 'Comment', field: 'post' })\n        comments: Comment[];\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n@ApiOperations(\n    ['create', 'read', 'remove']\n)\nexport class Comment {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'Post' })\n        post: Post;\n    @RelatedModel({ model: 'User', required: false })\n        user: User;\n    @TextField()\n        comment: string;\n\n    constructor(data?: Partial<Comment>) {\n        Object.assign(this, data);\n    }\n}\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(User);\nmodelManager.register(Post);\nmodelManager.register(Comment);\n\nexport const api = new ModelApiManager(modelManager);\napi.register(User);\napi.register(Post);\napi.register(Comment)\n\n\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-api"
        },
        {
            "location": "/components/rev-api/#rev-api-revjs-graphql-api-generator",
            "text": "The  rev-api  module provides the following:   A  ModelApiManager  object, for registering your models to be exposed via\n   the GraphQL API  An  @ApiOperations  decorator, for annotating your models with the operations\n   that are allowed on them ( read ,  create , etc.)  An  @ApiMethod  decorator, for annotating any model methods that you\n   want to expose as GraphQL mutations.   For more information, check out  Creating an API  Jump to the  rev-api API Documentation",
            "title": "rev-api - RevJS GraphQL API Generator"
        },
        {
            "location": "/components/rev-api/#example",
            "text": "The example below creates a few models and assigns them to a ModelApiManager.  \nimport {\n    AutoNumberField, TextField, RelatedModel, RelatedModelList,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\nimport { ApiOperations } from 'rev-api/lib/decorators';\nimport { ModelApiManager } from 'rev-api';\n\n// Use the @ApiOperations decorator to specify what operations are allowed for each model\n\n@ApiOperations(\n    ['read']\n)\nexport class User {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        username: string;\n    @RelatedModelList({ model: 'Post', field: 'user' })\n        posts: Post[];\n    @RelatedModelList({ model: 'Comment', field: 'user' })\n        comments: Comment[];\n\n    constructor(data?: Partial<User>) {\n        Object.assign(this, data);\n    }\n}\n\n@ApiOperations(\n    ['create', 'read', 'update', 'remove']\n)\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'User' })\n        user: User;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @RelatedModelList({ model: 'Comment', field: 'post' })\n        comments: Comment[];\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n@ApiOperations(\n    ['create', 'read', 'remove']\n)\nexport class Comment {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'Post' })\n        post: Post;\n    @RelatedModel({ model: 'User', required: false })\n        user: User;\n    @TextField()\n        comment: string;\n\n    constructor(data?: Partial<Comment>) {\n        Object.assign(this, data);\n    }\n}\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(User);\nmodelManager.register(Post);\nmodelManager.register(Comment);\n\nexport const api = new ModelApiManager(modelManager);\napi.register(User);\napi.register(Post);\napi.register(Comment)",
            "title": "Example"
        },
        {
            "location": "/components/rev-api/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/components/rev-api-client/",
            "text": "rev-api-client - RevJS GraphQL API Client Backend\n\u00b6\n\n\nThe \nrev-api-client\n module provides a \nModelApiBackend\n RevJS backend, which\nallows you to create, read, update and delete model data from the client in\nexactly the same way you do on the server.\n\n\nJump to the \nrev-api-client API Documentation\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-api-client"
        },
        {
            "location": "/components/rev-api-client/#rev-api-client-revjs-graphql-api-client-backend",
            "text": "The  rev-api-client  module provides a  ModelApiBackend  RevJS backend, which\nallows you to create, read, update and delete model data from the client in\nexactly the same way you do on the server.  Jump to the  rev-api-client API Documentation",
            "title": "rev-api-client - RevJS GraphQL API Client Backend"
        },
        {
            "location": "/components/rev-api-client/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/components/rev-ui/",
            "text": "rev-ui\n\u00b6\n\n\nCheck out \nCreating a User Interface\n\n\nJump to the \nrev-ui API Documentation\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-ui"
        },
        {
            "location": "/components/rev-ui/#rev-ui",
            "text": "Check out  Creating a User Interface  Jump to the  rev-ui API Documentation",
            "title": "rev-ui"
        },
        {
            "location": "/components/rev-ui/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/changelog/",
            "text": "Change Log\n\u00b6\n\n\nRevJS Module Releases\n\u00b6\n\n\n0.20.0 - 19th June 2018\n\u00b6\n\n\nrev-ui\n\n\n\n\n<DetailView />\n has a new \nrelated\n prop for loading \nRelatedModel\n fields\n\n\n<Field />\n component now supports sub-fields, e.g. \naddress.address1\n\n\n<SaveAction />\n now triggers validation before saving\n\n\n\n\n0.19.0 - 15th June 2018\n\u00b6\n\n\nrev-models\n\n\n\n\nModelManager.isNew()\n throw better error when model is null or undefined\n\n\nModelManager.register()\n now does a test instantiation of the model, and throws an error if the constructor sets any default values\n\n\nAdded \nIModel.defaults()\n method, to be used for setting default field values\n\n\nAdded \nModelManager.getNew()\n method, for returning models with default values applied\n\n\n\n\nrev-ui\n\n\n\n\nAdd a \ndefaultAction\n prop for \n<PostAction />\n, \n<SaveAction />\n, etc. components\n\n\n<DetailView />\n now applies default values set in \nIModel.defaults()\n\n\n\n\nrev-ui-materialui\n\n\n\n\nMUISelectField - store \nnull\n instead of empty string when empty option is selected\n\n\n\n\n0.18.0 - 6th June 2018\n\u00b6\n\n\n\n\nBuild fix: clean lib/** before building\n\n\n\n\nrev-api\n\n\n\n\nExport IModelApiManager interface from \nrev-api\n root\n\n\n\n\nrev-ui-materialui\n\n\n\n\nUpdate to @material-ui/core and @material-ui/icons @ 1.x\n\n\n\n\n0.17.0 - 13th May 2018\n\u00b6\n\n\n\n\nUpgraded to latest devDependencies\n\n\nAdded support for TypeScript \nstrict\n mode\n\n\nAdded seperate \nParams\n interfaces for \nIBackend\n methods\n\n\n\n\nrev-ui-materialui\n\n\n\n\nUpgrade to \nmaterial-ui@1.0.0-beta.41\n \n\n\nUpgrade to \n@material-ui/icons@1.0.0-beta.42\n\n\n\n\n0.16.3 - 10th April 2018\n\u00b6\n\n\nrev-ui-materialui\n\n\n\n\nAdded \nMUIBooleanField\n (checkbox)\n\n\nAdded \n<SearchField />\n for \nBooleanField\n\n\n\n\n0.16.2 - 1st April 2018\n\u00b6\n\n\n\n\nREADME updates\n\n\n\n\n0.16.1 - 31th March 2018\n\u00b6\n\n\nrev-ui-materialui\n\n\n\n\nAdded \n<SearchField />\n for \nSelectField\n\n\nAdded \n<SearchField />\n for \nDateField\n\n\n\n\n0.16.0 - 30th March 2018\n\u00b6\n\n\nrev-models\n\n\n\n\nThe \n_like\n query operator is now case-insensitive by default\n\n\n\n\nrev-ui\n & \nrev-ui-materialui\n\n\n\n\nAdded new \n<SearchView />\n, \n<SearchField />\n and \n<SearchAction />\n components.\n\n\nUpdate Docs & Examples\n\n\n\n\n0.15.2 - 30th March 2018\n\u00b6\n\n\nrev-ui\n\n\n\n\nAdded \nMUIDateField\n component\n\n\n\n\n0.15.1 - 30th March 2018\n\u00b6\n\n\nrev-ui\n\n\n\n\nAdded missing \n@types/prop-types\n dependency\n\n\n\n\n0.15.0 - 25th March 2018\n\u00b6\n\n\nrev-ui\n\n\n\n\nExported 'Component' interfaces from the root, for easier use\n\n\nIListViewComponentProps\n now generic to enable types on props.records\n\n\nListView.fields\n prop now optional\n\n\nIListViewComponentProps.records -> results (to be consistent with IModelOperationResult)\n\n\nUI Components now support pass-through of standard properties (e.g. style)\n\n\nAdded \nMUISelectField\n and \nMUIRelatedModelField\n implementations\n\n\n\n\n0.14.0 - 18th March 2018\n\u00b6\n\n\nrev-ui\n\n\n\n\nRefactoring to make ListView and DetailView consistent\n\n\nIModelContext -> IDetailViewContext\n\n\nAdded initial API documentation\n\n\n\n\n0.13.0 - 17th March 2018\n\u00b6\n\n\nrev-models\n\n\n\n\nAdded support for fields with property getters. By default, RevJS fields\n  with a getter function are set to not be stored (\nField.options.stored == false\n)\n\n\n\n\nrev-api\n & \nrev-api-client\n\n\n\n\nAPI now passes all RevJS standard backend tests (including related model queries)\n\n\n\n\nrev-ui\n\n\n\n\n<ListView />\n Renamed \nrowLimit\n property to \nlimit\n (to match IReadOptions)\n\n\n<ListView />\n Added \nwhere\n property for setting list filter\n\n\n<ListView />\n Added \nrelated\n property to included related model data\n\n\n<ListView />\n Added \norderBy\n property for sorting results\n\n\n<ListView />\n supports RelatedModelFields (uses toString() on the class)\n\n\n\n\n0.12.0 - 11th March 2018\n\u00b6\n\n\nrev-api\n\n\n\n\nImprove error when a GraphQL fieldMapping is not found for a field type\n\n\nFix GraphQL mappings for EmailField, URLField and PasswordField\n\n\n\n\nrev-api-client\n\n\n\n\nFix error when model fields are null\n\n\n\n\nrev-ui\n\n\n\n\nAdded viewContext.remove() method. We now have full CRUD :)\n\n\nAdded \n<RemoveAction />\n component for removing the current record in a \n<DetailView />\n\n\nAll Action components now have default labels\n\n\n\n\n0.11.0 - 8th March 2018\n\u00b6\n\n\n\n\nFirst public release of \nrev-backend-mongodb\n. Passes full backend test suite\n\n\nDocs and guides updated\n\n\n\n\n0.10.0 - 3rd March 2018\n\u00b6\n\n\n\n\nRemove unnecessary \nIModelValidationResult.validationFinished\n property\n\n\nDocs updates\n\n\n\n\n0.9.1 - 3rd March 2018\n\u00b6\n\n\n\n\nDocs update\n\n\nMark some module internals as @privat",
            "title": "Change Log"
        },
        {
            "location": "/changelog/#change-log",
            "text": "",
            "title": "Change Log"
        },
        {
            "location": "/changelog/#revjs-module-releases",
            "text": "",
            "title": "RevJS Module Releases"
        },
        {
            "location": "/changelog/#0200-19th-june-2018",
            "text": "rev-ui   <DetailView />  has a new  related  prop for loading  RelatedModel  fields  <Field />  component now supports sub-fields, e.g.  address.address1  <SaveAction />  now triggers validation before saving",
            "title": "0.20.0 - 19th June 2018"
        },
        {
            "location": "/changelog/#0190-15th-june-2018",
            "text": "rev-models   ModelManager.isNew()  throw better error when model is null or undefined  ModelManager.register()  now does a test instantiation of the model, and throws an error if the constructor sets any default values  Added  IModel.defaults()  method, to be used for setting default field values  Added  ModelManager.getNew()  method, for returning models with default values applied   rev-ui   Add a  defaultAction  prop for  <PostAction /> ,  <SaveAction /> , etc. components  <DetailView />  now applies default values set in  IModel.defaults()   rev-ui-materialui   MUISelectField - store  null  instead of empty string when empty option is selected",
            "title": "0.19.0 - 15th June 2018"
        },
        {
            "location": "/changelog/#0180-6th-june-2018",
            "text": "Build fix: clean lib/** before building   rev-api   Export IModelApiManager interface from  rev-api  root   rev-ui-materialui   Update to @material-ui/core and @material-ui/icons @ 1.x",
            "title": "0.18.0 - 6th June 2018"
        },
        {
            "location": "/changelog/#0170-13th-may-2018",
            "text": "Upgraded to latest devDependencies  Added support for TypeScript  strict  mode  Added seperate  Params  interfaces for  IBackend  methods   rev-ui-materialui   Upgrade to  material-ui@1.0.0-beta.41    Upgrade to  @material-ui/icons@1.0.0-beta.42",
            "title": "0.17.0 - 13th May 2018"
        },
        {
            "location": "/changelog/#0163-10th-april-2018",
            "text": "rev-ui-materialui   Added  MUIBooleanField  (checkbox)  Added  <SearchField />  for  BooleanField",
            "title": "0.16.3 - 10th April 2018"
        },
        {
            "location": "/changelog/#0162-1st-april-2018",
            "text": "README updates",
            "title": "0.16.2 - 1st April 2018"
        },
        {
            "location": "/changelog/#0161-31th-march-2018",
            "text": "rev-ui-materialui   Added  <SearchField />  for  SelectField  Added  <SearchField />  for  DateField",
            "title": "0.16.1 - 31th March 2018"
        },
        {
            "location": "/changelog/#0160-30th-march-2018",
            "text": "rev-models   The  _like  query operator is now case-insensitive by default   rev-ui  &  rev-ui-materialui   Added new  <SearchView /> ,  <SearchField />  and  <SearchAction />  components.  Update Docs & Examples",
            "title": "0.16.0 - 30th March 2018"
        },
        {
            "location": "/changelog/#0152-30th-march-2018",
            "text": "rev-ui   Added  MUIDateField  component",
            "title": "0.15.2 - 30th March 2018"
        },
        {
            "location": "/changelog/#0151-30th-march-2018",
            "text": "rev-ui   Added missing  @types/prop-types  dependency",
            "title": "0.15.1 - 30th March 2018"
        },
        {
            "location": "/changelog/#0150-25th-march-2018",
            "text": "rev-ui   Exported 'Component' interfaces from the root, for easier use  IListViewComponentProps  now generic to enable types on props.records  ListView.fields  prop now optional  IListViewComponentProps.records -> results (to be consistent with IModelOperationResult)  UI Components now support pass-through of standard properties (e.g. style)  Added  MUISelectField  and  MUIRelatedModelField  implementations",
            "title": "0.15.0 - 25th March 2018"
        },
        {
            "location": "/changelog/#0140-18th-march-2018",
            "text": "rev-ui   Refactoring to make ListView and DetailView consistent  IModelContext -> IDetailViewContext  Added initial API documentation",
            "title": "0.14.0 - 18th March 2018"
        },
        {
            "location": "/changelog/#0130-17th-march-2018",
            "text": "rev-models   Added support for fields with property getters. By default, RevJS fields\n  with a getter function are set to not be stored ( Field.options.stored == false )   rev-api  &  rev-api-client   API now passes all RevJS standard backend tests (including related model queries)   rev-ui   <ListView />  Renamed  rowLimit  property to  limit  (to match IReadOptions)  <ListView />  Added  where  property for setting list filter  <ListView />  Added  related  property to included related model data  <ListView />  Added  orderBy  property for sorting results  <ListView />  supports RelatedModelFields (uses toString() on the class)",
            "title": "0.13.0 - 17th March 2018"
        },
        {
            "location": "/changelog/#0120-11th-march-2018",
            "text": "rev-api   Improve error when a GraphQL fieldMapping is not found for a field type  Fix GraphQL mappings for EmailField, URLField and PasswordField   rev-api-client   Fix error when model fields are null   rev-ui   Added viewContext.remove() method. We now have full CRUD :)  Added  <RemoveAction />  component for removing the current record in a  <DetailView />  All Action components now have default labels",
            "title": "0.12.0 - 11th March 2018"
        },
        {
            "location": "/changelog/#0110-8th-march-2018",
            "text": "First public release of  rev-backend-mongodb . Passes full backend test suite  Docs and guides updated",
            "title": "0.11.0 - 8th March 2018"
        },
        {
            "location": "/changelog/#0100-3rd-march-2018",
            "text": "Remove unnecessary  IModelValidationResult.validationFinished  property  Docs updates",
            "title": "0.10.0 - 3rd March 2018"
        },
        {
            "location": "/changelog/#091-3rd-march-2018",
            "text": "Docs update  Mark some module internals as @privat",
            "title": "0.9.1 - 3rd March 2018"
        }
    ]
}