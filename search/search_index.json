{
    "docs": [
        {
            "location": "/",
            "text": "RevJS - Rev up your data-driven JS app development!\n\u00b6\n\n\nWhat is RevJS?\n\u00b6\n\n\nRevJS is a suite of JavaScript modules designed to speed up development of\ndata-driven JS applications.\n\n\nRevJS allows you to\n\n\n\n\nDefine a relational \ndata model\n using plain JS classes, and built-in or custom field types\n\n\nDefine custom \nvalidation logic\n directly in your models\n\n\nEasily create a \nGraphQL API\n to make your models available over the network\n\n\nQuickly build a \nuser interface\n for the web or mobile, using our React higher-order components\n\n\n\n\nExample\n\u00b6\n\n\nThe below example shows how to create a simple data model with RevJS's \nrev-models\n module:\n\n\n\nimport {\n    AutoNumberField, TextField, SelectField, IntegerField,\n    RelatedModel, ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define models\n\nexport class City {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        name: string;\n\n    constructor(data?: Partial<City>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Customer {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        first_name: string;\n    @TextField()\n        last_name: string;\n    @IntegerField()\n        age: number;\n    @SelectField({ selection: [['M', 'Male'], ['F', 'Female']] })\n        gender: string;\n    @RelatedModel({ model: 'City', required: false })\n        city: City;\n\n    constructor(data?: Partial<Customer>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager and register the models\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\n\nmodelManager.register(City);\nmodelManager.register(Customer);\n\n\n\n\nResJS is designed for use with \nTypeScript\n, to give you all the\nbenefits of strong typing and intellisense, however it should work with\nstandard ES6+ too. (we're looking for someone interested in creating and\nmaintaining a revjs ES6+ guide!...)\n\n\nComponents\n\u00b6\n\n\n\n\nrev-models\n - Define your Data Models and Validation,\n   and easily test them out with the in-memory storage provided.\n\n\nrev-backend-mongodb\n - Store your RevJS models in a MongoDB Database\n\n\nrev-api\n - Expose your data model via an automatically-generated GraphQL API\n\n\nrev-api-client\n - Access your server-side models\n   in the browser or on a mobile device, using the same API and validation logic.\n\n\nrev-ui\n - Quickly build user interfaces with data from your RevJS backend using our\n  React higher-order components.\n\n\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!\n\n\nLicense\n\u00b6\n\n\nMIT",
            "title": "Welcome to RevJS!"
        },
        {
            "location": "/#revjs-rev-up-your-data-driven-js-app-development",
            "text": "",
            "title": "RevJS - Rev up your data-driven JS app development!"
        },
        {
            "location": "/#what-is-revjs",
            "text": "RevJS is a suite of JavaScript modules designed to speed up development of\ndata-driven JS applications.  RevJS allows you to   Define a relational  data model  using plain JS classes, and built-in or custom field types  Define custom  validation logic  directly in your models  Easily create a  GraphQL API  to make your models available over the network  Quickly build a  user interface  for the web or mobile, using our React higher-order components",
            "title": "What is RevJS?"
        },
        {
            "location": "/#example",
            "text": "The below example shows how to create a simple data model with RevJS's  rev-models  module:  \nimport {\n    AutoNumberField, TextField, SelectField, IntegerField,\n    RelatedModel, ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define models\n\nexport class City {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        name: string;\n\n    constructor(data?: Partial<City>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Customer {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        first_name: string;\n    @TextField()\n        last_name: string;\n    @IntegerField()\n        age: number;\n    @SelectField({ selection: [['M', 'Male'], ['F', 'Female']] })\n        gender: string;\n    @RelatedModel({ model: 'City', required: false })\n        city: City;\n\n    constructor(data?: Partial<Customer>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager and register the models\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\n\nmodelManager.register(City);\nmodelManager.register(Customer);  ResJS is designed for use with  TypeScript , to give you all the\nbenefits of strong typing and intellisense, however it should work with\nstandard ES6+ too. (we're looking for someone interested in creating and\nmaintaining a revjs ES6+ guide!...)",
            "title": "Example"
        },
        {
            "location": "/#components",
            "text": "rev-models  - Define your Data Models and Validation,\n   and easily test them out with the in-memory storage provided.  rev-backend-mongodb  - Store your RevJS models in a MongoDB Database  rev-api  - Expose your data model via an automatically-generated GraphQL API  rev-api-client  - Access your server-side models\n   in the browser or on a mobile device, using the same API and validation logic.  rev-ui  - Quickly build user interfaces with data from your RevJS backend using our\n  React higher-order components.",
            "title": "Components"
        },
        {
            "location": "/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/#license",
            "text": "MIT",
            "title": "License"
        },
        {
            "location": "/models/creating_models/",
            "text": "Creating your Data Model\n\u00b6\n\n\nDefining Models\n\u00b6\n\n\nA \"Model\" in RevJS is simply a JavaScript Class with some additional properties\nthat tell RevJS how to validate, store and retrieve data.\n\n\nIf you are using \nTypeScript\n, then you can use decorators to easily define\nthe properties of your model.\n\n\nIn order to use your model classes, you must register them using the\n\nregister()\n method of a\n\nModelManager\n instance.\n\n\nThe example below shows how to create two related models, and register them\nwith a ModelManager:\n\n\n\nimport {\n    AutoNumberField, TextField, SelectField, IntegerField,\n    RelatedModel, ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define models\n\nexport class City {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        name: string;\n\n    constructor(data?: Partial<City>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Customer {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        first_name: string;\n    @TextField()\n        last_name: string;\n    @IntegerField()\n        age: number;\n    @SelectField({ selection: [['M', 'Male'], ['F', 'Female']] })\n        gender: string;\n    @RelatedModel({ model: 'City', required: false })\n        city: City;\n\n    constructor(data?: Partial<Customer>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager and register the models\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\n\nmodelManager.register(City);\nmodelManager.register(Customer);\n\n\n\n\nBuilt-in Field Types\n\u00b6\n\n\nRevJS ships with a set 15 standard field types, and you can also create your own\nby extending the \nField\n class.\n\n\n\n\nTextField\n - Single, or multi-line text field\n\n\nEmailField\n - TextField with e-mail address validation\n\n\nUrlField\n - TextField with URL validation\n\n\nPasswordField\n - Password field\n\n\nNumberField\n - Number entry field (any numeric value)\n\n\nIntegerField\n - Integer entry field\n\n\nAutoNumberField\n - Auto-generated, sequential integer field\n\n\nBooleanField\n - True / false\n\n\nSelectField\n - Single-item selection field\n\n\nMultiSelectField\n - Multiple-item selection field\n\n\nDateField\n - Date-only field\n\n\nTimeField\n - Time-only field\n\n\nDateTimeField\n - Date & Time field\n\n\nRelatedModelField\n - Foreign-key link to a related model\n\n\nRelatedModelListField\n - List of related models\n\n\n\n\nValidation\n\u00b6\n\n\nIn addition to the built-in, configurable validation provided by fields, you\ncan specify your own validation logic directly on your models by defining a\n\nvalidate()\n or \nvalidateAsync()\n method, as shown in the\nexample below:\n\n\n\nimport {\n    AutoNumberField, TextField, BooleanField,\n    ModelManager, InMemoryBackend, IValidationContext\n} from 'rev-models';\n\n// Define model with some custom validation\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @BooleanField()\n        is_published: boolean;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n\n    // Define synchronous validation\n    validate(ctx: IValidationContext) {\n        if (this.body.includes('fake news')) {\n            ctx.result.addFieldError('body', 'Body must not contain fake news!');\n        }\n    }\n\n    // Define some asynchronous validation\n    async validateAsync(ctx: IValidationContext) {\n        if (ctx.operation.operationName == 'create') {\n            const duplicates = await ctx.manager.read(Post, {\n                where: {\n                    title: { _like: this.title }\n                }\n            });\n            if (duplicates.meta.totalCount > 0) {\n                ctx.result.addFieldError('title', 'Cannot create post with a duplicate title!');\n            }\n        }\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n// Create some data\n\n(async () => {\n    try {\n\n        // Create a valid post\n        await modelManager.create(new Post({\n            title: 'This is a valid post',\n            body: 'No alternative facts here!',\n            is_published: true\n        }));\n\n        // Try to create a duplicate post...\n        await modelManager.create(new Post({\n            title: 'This is a valid post',\n            body: 'Not really! Its a duplicate, so should cause an error...',\n            is_published: true\n        }));\n\n    }\n    catch (e) {\n        console.error(e.message);\n    }\n})();\n\n\n\n\nThe output of the above code is:\n\n\nValidationError\n * title: Cannot create post with a duplicate title!\n\n\n\n\nFor further information on model validation functions, check out the\n\nIModel\n interface\n\n\nRevJS Backends\n\u00b6\n\n\nRevJS has the concept of a \npluggable backend architecture\n, to allow it to\nsupport storage of models in a variety of databases and across the network\nusing APIs. The following backends are currently available:\n\n\n\n\nInMemoryBackend\n - stores your\n   model data in-memory. Ideal for initial development and automated testing.\n\n\nModelApiBackend\n - designed for use in the browser or a mobile app.\n   Uses the API created by \nrev-api\n to store and retrieve your models.\n\n\nMongoDBBackend\n - stores and retrieves your data from MongoDB\n\n\n\n\nWe have defined a standard \nIBackend\n\ninterface, as well as a\n\nStandard Test Suite\n\nto aid with new backend development, and are keen to accept any contributions\nfrom the community!",
            "title": "Creating Models"
        },
        {
            "location": "/models/creating_models/#creating-your-data-model",
            "text": "",
            "title": "Creating your Data Model"
        },
        {
            "location": "/models/creating_models/#defining-models",
            "text": "A \"Model\" in RevJS is simply a JavaScript Class with some additional properties\nthat tell RevJS how to validate, store and retrieve data.  If you are using  TypeScript , then you can use decorators to easily define\nthe properties of your model.  In order to use your model classes, you must register them using the register()  method of a ModelManager  instance.  The example below shows how to create two related models, and register them\nwith a ModelManager:  \nimport {\n    AutoNumberField, TextField, SelectField, IntegerField,\n    RelatedModel, ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define models\n\nexport class City {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        name: string;\n\n    constructor(data?: Partial<City>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Customer {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        first_name: string;\n    @TextField()\n        last_name: string;\n    @IntegerField()\n        age: number;\n    @SelectField({ selection: [['M', 'Male'], ['F', 'Female']] })\n        gender: string;\n    @RelatedModel({ model: 'City', required: false })\n        city: City;\n\n    constructor(data?: Partial<Customer>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager and register the models\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\n\nmodelManager.register(City);\nmodelManager.register(Customer);",
            "title": "Defining Models"
        },
        {
            "location": "/models/creating_models/#built-in-field-types",
            "text": "RevJS ships with a set 15 standard field types, and you can also create your own\nby extending the  Field  class.   TextField  - Single, or multi-line text field  EmailField  - TextField with e-mail address validation  UrlField  - TextField with URL validation  PasswordField  - Password field  NumberField  - Number entry field (any numeric value)  IntegerField  - Integer entry field  AutoNumberField  - Auto-generated, sequential integer field  BooleanField  - True / false  SelectField  - Single-item selection field  MultiSelectField  - Multiple-item selection field  DateField  - Date-only field  TimeField  - Time-only field  DateTimeField  - Date & Time field  RelatedModelField  - Foreign-key link to a related model  RelatedModelListField  - List of related models",
            "title": "Built-in Field Types"
        },
        {
            "location": "/models/creating_models/#validation",
            "text": "In addition to the built-in, configurable validation provided by fields, you\ncan specify your own validation logic directly on your models by defining a validate()  or  validateAsync()  method, as shown in the\nexample below:  \nimport {\n    AutoNumberField, TextField, BooleanField,\n    ModelManager, InMemoryBackend, IValidationContext\n} from 'rev-models';\n\n// Define model with some custom validation\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @BooleanField()\n        is_published: boolean;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n\n    // Define synchronous validation\n    validate(ctx: IValidationContext) {\n        if (this.body.includes('fake news')) {\n            ctx.result.addFieldError('body', 'Body must not contain fake news!');\n        }\n    }\n\n    // Define some asynchronous validation\n    async validateAsync(ctx: IValidationContext) {\n        if (ctx.operation.operationName == 'create') {\n            const duplicates = await ctx.manager.read(Post, {\n                where: {\n                    title: { _like: this.title }\n                }\n            });\n            if (duplicates.meta.totalCount > 0) {\n                ctx.result.addFieldError('title', 'Cannot create post with a duplicate title!');\n            }\n        }\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n// Create some data\n\n(async () => {\n    try {\n\n        // Create a valid post\n        await modelManager.create(new Post({\n            title: 'This is a valid post',\n            body: 'No alternative facts here!',\n            is_published: true\n        }));\n\n        // Try to create a duplicate post...\n        await modelManager.create(new Post({\n            title: 'This is a valid post',\n            body: 'Not really! Its a duplicate, so should cause an error...',\n            is_published: true\n        }));\n\n    }\n    catch (e) {\n        console.error(e.message);\n    }\n})();  The output of the above code is:  ValidationError\n * title: Cannot create post with a duplicate title!  For further information on model validation functions, check out the IModel  interface",
            "title": "Validation"
        },
        {
            "location": "/models/creating_models/#revjs-backends",
            "text": "RevJS has the concept of a  pluggable backend architecture , to allow it to\nsupport storage of models in a variety of databases and across the network\nusing APIs. The following backends are currently available:   InMemoryBackend  - stores your\n   model data in-memory. Ideal for initial development and automated testing.  ModelApiBackend  - designed for use in the browser or a mobile app.\n   Uses the API created by  rev-api  to store and retrieve your models.  MongoDBBackend  - stores and retrieves your data from MongoDB   We have defined a standard  IBackend \ninterface, as well as a Standard Test Suite \nto aid with new backend development, and are keen to accept any contributions\nfrom the community!",
            "title": "RevJS Backends"
        },
        {
            "location": "/models/creating_data/",
            "text": "Creating Model Data\n\u00b6\n\n\nSince RevJS models are just JavaScript classes, you create new records by\ncreating new instances of your model class, and passing them to the\n\nModelManager.create()\n\nmethod.\n\n\nDefining Model Constructors\n\u00b6\n\n\nTo make it easier to populate new records, we recommend adding a constructor\nfunction to your class, as shown in the example below:\n\n\nclass MyCoolModel {\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n\n    constructor(data?: Partial<MyCoolModel>) {\n        Object.assign(this, data);\n    }\n}\n\n\n\n\nDoing this means you can then construct new records with new data in a single\nstatement, as shown below:\n\n\nconst new_record = new MyCoolModel({\n    title: 'New Record',\n    body: 'This is a cool new record with some data!'\n});\n\n\n\n\nIMPORTANT NOTE:\n It should also be possible to construct instances\nof your model \nwithout\n passing any data. RevJS needs to do this when\nhydrating models from data retrieved from a backend.\n\n\nStoring Model Data\n\u00b6\n\n\nTo store data for your model in a backend, simply pass a populated instance\nof your model to the\n\nModelManager.create()\n\nmethod.\n\n\nThe model data will be validated before it is passed to the backend. If any\nvalidation errors occur, a\n\nValidationError\n will be\nthrown.\n\n\nThe example below shows how to define a model and create some data for it:\n\n\n\nimport {\n    AutoNumberField, TextField, SelectField,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define model\n\nconst POST_STATUS = [\n    ['draft', 'Draft'],\n    ['published', 'Published']\n];\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField({ minLength: 5, maxLength: 100 })\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @SelectField({ selection: POST_STATUS })\n        status: string;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n(async () => {\n\n    // Create some data\n\n    await modelManager.create(new Post({\n        title: 'My First Post',\n        body: 'This is a really cool post made in RevJS',\n        status: 'draft'\n    }));\n\n    await modelManager.create(new Post({\n        title: 'RevJS is awesome!',\n        body: 'I should use it for ALL TEH THINGZZZ!',\n        status: 'published'\n    }));\n\n    // Read it back\n\n    const res = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { title: { _like: '%RevJS%' }},\n                { body: { _like: '%RevJS%' }}\n            ]\n        }\n    });\n\n    console.log(res.results);\n\n})();",
            "title": "Creating Model Data"
        },
        {
            "location": "/models/creating_data/#creating-model-data",
            "text": "Since RevJS models are just JavaScript classes, you create new records by\ncreating new instances of your model class, and passing them to the ModelManager.create() \nmethod.",
            "title": "Creating Model Data"
        },
        {
            "location": "/models/creating_data/#defining-model-constructors",
            "text": "To make it easier to populate new records, we recommend adding a constructor\nfunction to your class, as shown in the example below:  class MyCoolModel {\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n\n    constructor(data?: Partial<MyCoolModel>) {\n        Object.assign(this, data);\n    }\n}  Doing this means you can then construct new records with new data in a single\nstatement, as shown below:  const new_record = new MyCoolModel({\n    title: 'New Record',\n    body: 'This is a cool new record with some data!'\n});  IMPORTANT NOTE:  It should also be possible to construct instances\nof your model  without  passing any data. RevJS needs to do this when\nhydrating models from data retrieved from a backend.",
            "title": "Defining Model Constructors"
        },
        {
            "location": "/models/creating_data/#storing-model-data",
            "text": "To store data for your model in a backend, simply pass a populated instance\nof your model to the ModelManager.create() \nmethod.  The model data will be validated before it is passed to the backend. If any\nvalidation errors occur, a ValidationError  will be\nthrown.  The example below shows how to define a model and create some data for it:  \nimport {\n    AutoNumberField, TextField, SelectField,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define model\n\nconst POST_STATUS = [\n    ['draft', 'Draft'],\n    ['published', 'Published']\n];\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField({ minLength: 5, maxLength: 100 })\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @SelectField({ selection: POST_STATUS })\n        status: string;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n(async () => {\n\n    // Create some data\n\n    await modelManager.create(new Post({\n        title: 'My First Post',\n        body: 'This is a really cool post made in RevJS',\n        status: 'draft'\n    }));\n\n    await modelManager.create(new Post({\n        title: 'RevJS is awesome!',\n        body: 'I should use it for ALL TEH THINGZZZ!',\n        status: 'published'\n    }));\n\n    // Read it back\n\n    const res = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { title: { _like: '%RevJS%' }},\n                { body: { _like: '%RevJS%' }}\n            ]\n        }\n    });\n\n    console.log(res.results);\n\n})();",
            "title": "Storing Model Data"
        },
        {
            "location": "/models/reading_data/",
            "text": "Reading Model Data\n\u00b6\n\n\nOnce you have defined your models and created some data, you can read it back\nusing the\n\nModelManager.read()\n method.\n\n\nReading All Data\n\u00b6\n\n\nTo read all model data without applying any filters, simply pass the model\nclass to your ModelManager's \nread()\n function:\n\n\n\nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    const res = await modelManager.read(Post);\n\n    for (let post of res.results) {\n        console.log(post.title);\n    }\n})();\n\n\n\n\nIMPORTANT NOTE:\n To encourage use of paging, the \nread()\n function will\nonly return \nthe first 20 records\n by default. See below for how to use the\n\nlimit\n and \noffset\n options to \npage\n through the data.\n\n\nSearching for Data\n\u00b6\n\n\nRevJS uses a MongoDB-like query language for building search queries. Below are\nsome examples:\n\n\n\nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Find all posts in the 'technology' category that are published\n    const techPosts = await modelManager.read(Post, {\n        where: {\n            category: 'technology',\n            published: true\n        }\n    });\n    console.log('Tech Posts:', techPosts.results);\n\n    // Find all published posts in the 'science' OR 'technology' categories\n    const sciTechPosts = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { category: 'science' },\n                { category: 'technology' }\n            ],\n            published: true\n        }\n    });\n    console.log('Science & Technology Posts:', sciTechPosts.results);\n\n    // Find all posts with a rating greater than or equal to 3\n    const goodPosts = await modelManager.read(Post, {\n        where: {\n            rating: { _gte: 3 }\n        }\n    });\n    console.log('Good Posts:', goodPosts.results);\n\n})();\n\n\n\n\nRevJS Query Operators\n\u00b6\n\n\nLogical Operators\n\u00b6\n\n\nThese operators take an array of conditions (as per the \n_or\n example above).\n\n\n\n\n_and\n - all conditions in the array must be true\n\n\n_or\n - at least one of the conditions in the array must be true\n\n\n\n\nValue Operators\n\u00b6\n\n\nThese operators take a single value (as per the \n_gte\n example above).\n\n\n\n\n_eq\n - equals - field must exactly match the specified value\n\n\n_neq\n - not equals - field must not match the specified value\n\n\n_gt\n - greater than - field must be greater than the specified value\n\n\n_gte\n - greater than or equal to - field must be greater than or equal to the specified value\n\n\n_lt\n - less than - field must be less than the specified value\n\n\n_lte\n - less than or equal to - field must be less than or equal to the specified value\n\n\n_like\n - like - field must be like the specified value, which can include \n%\n symbols to match multiple characters (works as per the traditional SQL 'LIKE' clause)\n\n\n\n\nValue List Operators\n\u00b6\n\n\nThese operators take an array of values.\n\n\n\n\n_in\n - in - field must match one of the values in the array\n\n\n_nin\n - not in - field must not match any of the values in the array\n\n\n\n\nUsing \nlimit\n and \noffset\n\u00b6\n\n\nYou can use the \nlimit\n and \noffset\n options with the\n\nread()\n method, to\n\npage\n through query results, as shown in the examples below:\n\n\n\nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Get the first 3 published posts\n    const first3Posts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        offset: 0,\n        limit: 3\n    });\n    console.log('First 3 Published Posts:', first3Posts.results);\n\n    // Get the next 3 published posts\n    const next3Posts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        offset: 3,\n        limit: 3\n    });\n    console.log('Next 3 Posts:', next3Posts.results);\n\n    // Just get all the published posts (max 100)\n    const allPosts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        limit: 100\n    });\n    console.log('All Teh Posts:', allPosts.results);\n\n})();\n\n\n\n\nSorting Data\n\u00b6\n\n\nYou can use the \norderBy\n option to specify the order of the records that are\nretrieved from the backend. This option takes an array of field names, and the\nrecords are sorted by each of the specified fields, in order. You can optionally\nuse the \ndesc\n keyword after the field name, to sort the values in that field\nin descending order.\n\n\n\nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Read all published posts, sorted by Title\n    const postsByTitle = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        limit: 100,\n        orderBy: ['title']\n    });\n    console.log('Posts by Title:', postsByTitle.results);\n\n    // Read all posts, sorted by Title in descending order\n    const postsByTitleDesc = await modelManager.read(Post, {\n        limit: 100,\n        orderBy: ['title desc']\n    });\n    console.log('Posts by Titie in descending order:', postsByTitleDesc.results);\n\n    // Read the first 10 posts sorted by Rating, then by Title\n    const top10Posts = await modelManager.read(Post, {\n        limit: 10,\n        orderBy: ['rating desc', 'title']\n    });\n    console.log('Top Posts:', top10Posts.results);\n\n})();",
            "title": "Reading Model Data"
        },
        {
            "location": "/models/reading_data/#reading-model-data",
            "text": "Once you have defined your models and created some data, you can read it back\nusing the ModelManager.read()  method.",
            "title": "Reading Model Data"
        },
        {
            "location": "/models/reading_data/#reading-all-data",
            "text": "To read all model data without applying any filters, simply pass the model\nclass to your ModelManager's  read()  function:  \nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    const res = await modelManager.read(Post);\n\n    for (let post of res.results) {\n        console.log(post.title);\n    }\n})();  IMPORTANT NOTE:  To encourage use of paging, the  read()  function will\nonly return  the first 20 records  by default. See below for how to use the limit  and  offset  options to  page  through the data.",
            "title": "Reading All Data"
        },
        {
            "location": "/models/reading_data/#searching-for-data",
            "text": "RevJS uses a MongoDB-like query language for building search queries. Below are\nsome examples:  \nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Find all posts in the 'technology' category that are published\n    const techPosts = await modelManager.read(Post, {\n        where: {\n            category: 'technology',\n            published: true\n        }\n    });\n    console.log('Tech Posts:', techPosts.results);\n\n    // Find all published posts in the 'science' OR 'technology' categories\n    const sciTechPosts = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { category: 'science' },\n                { category: 'technology' }\n            ],\n            published: true\n        }\n    });\n    console.log('Science & Technology Posts:', sciTechPosts.results);\n\n    // Find all posts with a rating greater than or equal to 3\n    const goodPosts = await modelManager.read(Post, {\n        where: {\n            rating: { _gte: 3 }\n        }\n    });\n    console.log('Good Posts:', goodPosts.results);\n\n})();",
            "title": "Searching for Data"
        },
        {
            "location": "/models/reading_data/#revjs-query-operators",
            "text": "",
            "title": "RevJS Query Operators"
        },
        {
            "location": "/models/reading_data/#logical-operators",
            "text": "These operators take an array of conditions (as per the  _or  example above).   _and  - all conditions in the array must be true  _or  - at least one of the conditions in the array must be true",
            "title": "Logical Operators"
        },
        {
            "location": "/models/reading_data/#value-operators",
            "text": "These operators take a single value (as per the  _gte  example above).   _eq  - equals - field must exactly match the specified value  _neq  - not equals - field must not match the specified value  _gt  - greater than - field must be greater than the specified value  _gte  - greater than or equal to - field must be greater than or equal to the specified value  _lt  - less than - field must be less than the specified value  _lte  - less than or equal to - field must be less than or equal to the specified value  _like  - like - field must be like the specified value, which can include  %  symbols to match multiple characters (works as per the traditional SQL 'LIKE' clause)",
            "title": "Value Operators"
        },
        {
            "location": "/models/reading_data/#value-list-operators",
            "text": "These operators take an array of values.   _in  - in - field must match one of the values in the array  _nin  - not in - field must not match any of the values in the array",
            "title": "Value List Operators"
        },
        {
            "location": "/models/reading_data/#using-limit-and-offset",
            "text": "You can use the  limit  and  offset  options with the read()  method, to page  through query results, as shown in the examples below:  \nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Get the first 3 published posts\n    const first3Posts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        offset: 0,\n        limit: 3\n    });\n    console.log('First 3 Published Posts:', first3Posts.results);\n\n    // Get the next 3 published posts\n    const next3Posts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        offset: 3,\n        limit: 3\n    });\n    console.log('Next 3 Posts:', next3Posts.results);\n\n    // Just get all the published posts (max 100)\n    const allPosts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        limit: 100\n    });\n    console.log('All Teh Posts:', allPosts.results);\n\n})();",
            "title": "Using limit and offset"
        },
        {
            "location": "/models/reading_data/#sorting-data",
            "text": "You can use the  orderBy  option to specify the order of the records that are\nretrieved from the backend. This option takes an array of field names, and the\nrecords are sorted by each of the specified fields, in order. You can optionally\nuse the  desc  keyword after the field name, to sort the values in that field\nin descending order.  \nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Read all published posts, sorted by Title\n    const postsByTitle = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        limit: 100,\n        orderBy: ['title']\n    });\n    console.log('Posts by Title:', postsByTitle.results);\n\n    // Read all posts, sorted by Title in descending order\n    const postsByTitleDesc = await modelManager.read(Post, {\n        limit: 100,\n        orderBy: ['title desc']\n    });\n    console.log('Posts by Titie in descending order:', postsByTitleDesc.results);\n\n    // Read the first 10 posts sorted by Rating, then by Title\n    const top10Posts = await modelManager.read(Post, {\n        limit: 10,\n        orderBy: ['rating desc', 'title']\n    });\n    console.log('Top Posts:', top10Posts.results);\n\n})();",
            "title": "Sorting Data"
        },
        {
            "location": "/models/updating_data/",
            "text": "Updating Model Data\n\u00b6\n\n\nYou can update records using the\n\nModelManager.update()\n\nmethod. There are a couple of ways to use it:\n\n\nUpdating Data from Reads\n\u00b6\n\n\nIf you have retrieved some data via a\n\nread()\n operation, then you\ncan update the retrieved records directly, as shown in the example below:\n\n\nimport { City, modelManager } from './creating_models';\n\n(async () => {\n\n    await modelManager.create(new City({ name: 'Wellington' }));\n    await modelManager.create(new City({ name: 'Auckland' }));\n    await modelManager.create(new City({ name: 'Hamilton' }));\n    await modelManager.create(new City({ name: 'Christchurch' }));\n\n    // Retrieve Auckland's record\n    const cities = await modelManager.read(City, { where: {\n            name: 'Auckland'\n    }});\n    console.log('Original Record:', cities.results[0]);\n\n    // Change it's name and trigger an update\n    const auckland = cities.results[0];\n    auckland.name = 'City of Sails';\n\n    await modelManager.update(auckland);\n\n    // Check that Auckland's record has been updated\n    const cityRetrieved = await modelManager.read(City, { where: {\n            name: 'City of Sails'\n    }});\n    console.log('Updated Record:', cityRetrieved.results[0]);\n\n})();\n\n\n\n\nNOTE:\n In order to update records without specifying a \nwhere\n clause, your\nmodel must have a field with \nprimaryKey: true\n set.\n\n\nUpdating Data with a Where clause\n\u00b6\n\n\nIf you wish to modify one or more fields across \nmultiple records\n, you can\nuse the \nwhere\n clause, as shown in the example below:\n\n\nimport { Post, modelManager, createData } from './post_model';\n\n(async () => {\n    await createData();\n\n    // Count unpublished posts\n    const unpublishedPosts = await modelManager.read(Post, {\n        where: {\n            published: false\n        }\n    });\n    console.log('Number of unpublished posts:', unpublishedPosts.meta.totalCount);\n\n    // Publish all unpublished posts!\n    const publishResult = await modelManager.update(\n        new Post({\n            published: true\n        }),\n        {\n            where: {\n                published: false\n            }\n        }\n    );\n    console.log('Updated records:', publishResult.meta.totalCount);\n\n})();",
            "title": "Updating Model Data"
        },
        {
            "location": "/models/updating_data/#updating-model-data",
            "text": "You can update records using the ModelManager.update() \nmethod. There are a couple of ways to use it:",
            "title": "Updating Model Data"
        },
        {
            "location": "/models/updating_data/#updating-data-from-reads",
            "text": "If you have retrieved some data via a read()  operation, then you\ncan update the retrieved records directly, as shown in the example below:  import { City, modelManager } from './creating_models';\n\n(async () => {\n\n    await modelManager.create(new City({ name: 'Wellington' }));\n    await modelManager.create(new City({ name: 'Auckland' }));\n    await modelManager.create(new City({ name: 'Hamilton' }));\n    await modelManager.create(new City({ name: 'Christchurch' }));\n\n    // Retrieve Auckland's record\n    const cities = await modelManager.read(City, { where: {\n            name: 'Auckland'\n    }});\n    console.log('Original Record:', cities.results[0]);\n\n    // Change it's name and trigger an update\n    const auckland = cities.results[0];\n    auckland.name = 'City of Sails';\n\n    await modelManager.update(auckland);\n\n    // Check that Auckland's record has been updated\n    const cityRetrieved = await modelManager.read(City, { where: {\n            name: 'City of Sails'\n    }});\n    console.log('Updated Record:', cityRetrieved.results[0]);\n\n})();  NOTE:  In order to update records without specifying a  where  clause, your\nmodel must have a field with  primaryKey: true  set.",
            "title": "Updating Data from Reads"
        },
        {
            "location": "/models/updating_data/#updating-data-with-a-where-clause",
            "text": "If you wish to modify one or more fields across  multiple records , you can\nuse the  where  clause, as shown in the example below:  import { Post, modelManager, createData } from './post_model';\n\n(async () => {\n    await createData();\n\n    // Count unpublished posts\n    const unpublishedPosts = await modelManager.read(Post, {\n        where: {\n            published: false\n        }\n    });\n    console.log('Number of unpublished posts:', unpublishedPosts.meta.totalCount);\n\n    // Publish all unpublished posts!\n    const publishResult = await modelManager.update(\n        new Post({\n            published: true\n        }),\n        {\n            where: {\n                published: false\n            }\n        }\n    );\n    console.log('Updated records:', publishResult.meta.totalCount);\n\n})();",
            "title": "Updating Data with a Where clause"
        },
        {
            "location": "/models/deleting_data/",
            "text": "Deleting Model Data\n\u00b6\n\n\nYou can delete records using the\n\nModelManager.remove()\n\nmethod ('delete' is a reserved word in JavaScript). There are a couple of ways to use the remove() method:\n\n\nDeleting Data from Reads\n\u00b6\n\n\nIf you have retrieved some data via a\n\nread()\n operation, then you\ncan remove the retrieved records directly, as shown in the example below:\n\n\n\nimport { City, modelManager } from './creating_models';\n\n(async () => {\n\n    await modelManager.create(new City({ name: 'Wellington' }));\n    await modelManager.create(new City({ name: 'Auckland' }));\n    await modelManager.create(new City({ name: 'Hamilton' }));\n    await modelManager.create(new City({ name: 'Christchurch' }));\n\n    const origRecords = await modelManager.read(City);\n    console.log('Original Records:', origRecords.results);\n\n    // Retrieve Auckland\n    const cities = await modelManager.read(City, { where: {\n        name: 'Auckland'\n    }});\n\n    // Remove it!\n    await modelManager.remove(cities.results[0]);\n\n    // Retrieve remaining records\n    const newRecords = await modelManager.read(City);\n    console.log('Remaining Records:', newRecords.results);\n\n})();\n\n\n\n\nNOTE:\n In order to remove records without specifying a \nwhere\n clause, your\nmodel must have a field with \nprimaryKey: true\n set.\n\n\nDeleting Data with a Where clause\n\u00b6\n\n\nIf you wish to delete multiple records, you can\nuse the \nwhere\n clause, as shown in the example below:\n\n\nimport { Post, modelManager, createData } from './post_model';\n\n(async () => {\n    await createData();\n\n    // Count unpublished posts\n    const unpublishedPosts = await modelManager.read(Post, {\n        where: {\n            published: false\n        }\n    });\n    console.log('Number of unpublished posts:', unpublishedPosts.meta.totalCount);\n\n    // Delete all unpublished posts\n    const deleteResult = await modelManager.remove(new Post(), {\n        where: {\n            published: false\n        }\n    });\n    console.log('Deleted records:', deleteResult.meta.totalCount);\n\n})();",
            "title": "Deleting Model Data"
        },
        {
            "location": "/models/deleting_data/#deleting-model-data",
            "text": "You can delete records using the ModelManager.remove() \nmethod ('delete' is a reserved word in JavaScript). There are a couple of ways to use the remove() method:",
            "title": "Deleting Model Data"
        },
        {
            "location": "/models/deleting_data/#deleting-data-from-reads",
            "text": "If you have retrieved some data via a read()  operation, then you\ncan remove the retrieved records directly, as shown in the example below:  \nimport { City, modelManager } from './creating_models';\n\n(async () => {\n\n    await modelManager.create(new City({ name: 'Wellington' }));\n    await modelManager.create(new City({ name: 'Auckland' }));\n    await modelManager.create(new City({ name: 'Hamilton' }));\n    await modelManager.create(new City({ name: 'Christchurch' }));\n\n    const origRecords = await modelManager.read(City);\n    console.log('Original Records:', origRecords.results);\n\n    // Retrieve Auckland\n    const cities = await modelManager.read(City, { where: {\n        name: 'Auckland'\n    }});\n\n    // Remove it!\n    await modelManager.remove(cities.results[0]);\n\n    // Retrieve remaining records\n    const newRecords = await modelManager.read(City);\n    console.log('Remaining Records:', newRecords.results);\n\n})();  NOTE:  In order to remove records without specifying a  where  clause, your\nmodel must have a field with  primaryKey: true  set.",
            "title": "Deleting Data from Reads"
        },
        {
            "location": "/models/deleting_data/#deleting-data-with-a-where-clause",
            "text": "If you wish to delete multiple records, you can\nuse the  where  clause, as shown in the example below:  import { Post, modelManager, createData } from './post_model';\n\n(async () => {\n    await createData();\n\n    // Count unpublished posts\n    const unpublishedPosts = await modelManager.read(Post, {\n        where: {\n            published: false\n        }\n    });\n    console.log('Number of unpublished posts:', unpublishedPosts.meta.totalCount);\n\n    // Delete all unpublished posts\n    const deleteResult = await modelManager.remove(new Post(), {\n        where: {\n            published: false\n        }\n    });\n    console.log('Deleted records:', deleteResult.meta.totalCount);\n\n})();",
            "title": "Deleting Data with a Where clause"
        },
        {
            "location": "/models/related_data/",
            "text": "Working with Related Models\n\u00b6\n\n\nTo fully model your data, you will normally want to define relationships\nbetween your models.\n\n\nFor example, you might want to associate a \nPost\n model with a \nUser\n (the\nauthor), and also your \nPost\n model may have many \nComments\n linked with it.\n\n\nDefining Relationships\n\u00b6\n\n\nRevJS currently has two types of relational fields:\n\n\n\n\nA \nRelatedModel\n field is a\n  link from the current model to \none record from another model\n. In the\n  \nPost\n example above, you would add a \n@RelatedModel()\n field for the\n  \nuser\n field.\n\n\nA \nRelatedModelList\n\n  field allows access to \na list of records from another model\n, that are\n  linked to the current one via a RelatedModel field. In the \nPost\n example\n  above, you would add a \n@RelatedModelList()\n field for the \ncomments\n field.\n\n\n\n\nLets implement the \nPost\n, \nUser\n, \nComments\n example to show how these\nfields work:\n\n\n\n\nA \nUser\n can have a \nlist of Posts\n and a \nlist of Comments\n\n\nA \nPost\n is linked to a single \nUser\n. and can have a \nlist of Comments\n\n\nA \nComment\n is linked to a single \nUser\n and a single \nPost\n\n\n\n\n\nimport {\n    AutoNumberField, TextField, RelatedModel, RelatedModelList,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\nexport class User {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        username: string;\n    @RelatedModelList({ model: 'Post', field: 'user' })\n        posts: Post[];\n    @RelatedModelList({ model: 'Comment', field: 'user' })\n        comments: Comment[];\n\n    constructor(data?: Partial<User>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'User' })\n        user: User;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @RelatedModelList({ model: 'Comment', field: 'post' })\n        comments: Comment[];\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Comment {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'Post' })\n        post: Post;\n    @RelatedModel({ model: 'User', required: false })\n        user: User;\n    @TextField()\n        comment: string;\n\n    constructor(data?: Partial<Comment>) {\n        Object.assign(this, data);\n    }\n}\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(User);\nmodelManager.register(Post);\nmodelManager.register(Comment);\n\n\n\n\nCreating Related Model Data\n\u00b6\n\n\nAs with most RevJS operations, you can create relationships between models\nsimply by assigning values to JavaScript objects as you normally would, then\npassing the resulting object to the\n\ncreate()\n or\n\nupdate()\n methods of\nyour \nModelManager\n.\n\n\nThe below example shows how to create a set of related Users, Posts and\nComments:\n\n\n\nimport { User, Post, Comment, modelManager } from './creating_related_models';\n\nexport async function createData() {\n\n    // Create Users\n\n    const joe = (await modelManager.create(new User({\n        username: 'joe123'\n    }))).result;\n\n    const bill = (await modelManager.create(new User({\n        username: 'bill27'\n    }))).result;\n\n    const jane = (await modelManager.create(new User({\n        username: 'jane12'\n    }))).result;\n\n    // Create Posts\n\n    const post1 = (await modelManager.create(new Post({\n        title: 'Related Data in RevJS',\n        body: 'Pretty easy to do eh?',\n        user: jane\n    }))).result;\n\n    await modelManager.create(new Post({\n        title: 'The Rain in Spain',\n        body: 'Really is a pain?',\n        user: jane\n    }));\n\n    // Create Comments\n\n    await modelManager.create(new Comment({\n        comment: 'True!',\n        post: post1,\n        user: bill\n    }));\n\n    await modelManager.create(new Comment({\n        comment: 'Hmmm, but I reeeeaally like writing SQL...',\n        post: post1,\n        user: joe\n    }));\n\n\n\n\n\n\nReading Related Model Data\n\u00b6\n\n\nBy default, RevJS will NOT return related model information (for performance\nreasons). However, it is easy to request this data using the \nrelated\n option\nfor the\n\nModelManager.read()\n method.\n\n\nSee below examples for how to read related model data:\n\n\n\nimport { Post, modelManager } from './creating_related_models';\nimport { createData } from './creating_related_data';\n\n(async () => {\n    await createData();\n\n    // Read all posts (without related data)\n    const plainPosts = await modelManager.read(Post);\n    console.log('Plain posts:', plainPosts.results);\n\n    // Read all posts, including the 'user' field\n    const posts2 = await modelManager.read(Post, {\n        related: ['user']\n    });\n    console.log('Posts with User:', posts2.results);\n\n    // Read all posts, including the 'user' and 'comments'\n    const posts3 = await modelManager.read(Post, {\n        related: ['user', 'comments']\n    });\n    console.log('Posts with User and Comments:', posts3.results);\n\n    // Read all posts, including the 'user', 'comments' and 'comments.user'\n    const posts4 = await modelManager.read(Post, {\n        related: ['user', 'comments.user']\n    });\n    console.log('Posts with User, Comments and Comment Author:', posts4.results);\n\n})()\n\n\n\n\nUpdating Related Model Records\n\u00b6\n\n\nYou can change the record linked to a RevJS model simply by attaching a\ndifferent model instance, or setting the value to \nnull\n, as shown in the\nexamples below:\n\n\n\nimport { User, Post, Comment, modelManager } from './creating_related_models';\nimport { createData } from './creating_related_data';\n\n(async () => {\n    await createData();\n\n    // Get the first post\n    const post1 = (await modelManager.read(Post, { limit: 1 })).results[0];\n\n    // Get the first user\n    const user1 = (await modelManager.read(User, { limit: 1 })).results[0];\n\n    // Make user1 the author of post1\n    post1.user = user1;\n    await modelManager.update(post1);\n\n    // If we know the ID of the record we want to link, we can pass a new\n    // model instance containing the related ID:\n    post1.user = new User({ id: 2 });\n    await modelManager.update(post1);\n\n    // To un-link a model, set the RelatedModel field to null\n    const comment1 = (await modelManager.read(Comment, { limit: 1 })).results[0];\n    comment1.user = null;\n    await modelManager.update(comment1);\n\n})()\n\n\n\n\nNOTE:\n - RevJS supports assigning values to \nRelatedModel\n fields \nonly\n at\nthe moment. Changes to RelatedModelList fields do not get stored\ncurrently.\n\n\nSearching based on Related Model Data\n\u00b6\n\n\nRevJS allows you to search records based on the Primary Key values stored in\nRelatedModel fields. For example:\n\n\n// Retrieve all comments linked to User id = 1\nmodelManager.read(Comment, {\n    where: {\n        user: 1\n    }\n})\n\n// Retrieve all comments that are not linked to a user\nmodelManager.read(Comment, {\n    where: {\n        user: null\n    }\n})\n\n\n\n\nRevJS does \nnot yet\n support querying for records based on properties of related\nrecords. For example, the following is \nnot yet possible\n, but would be cool:\n\n\nmodelManager.read(User, {\n    where: {\n        'posts.title': { _like: '%fake news%' }\n    }\n})\n\n\n\n\nWe hope to implement something like this in the future, and of course welcome\ncontributions from the community! :)",
            "title": "Working with Related Models"
        },
        {
            "location": "/models/related_data/#working-with-related-models",
            "text": "To fully model your data, you will normally want to define relationships\nbetween your models.  For example, you might want to associate a  Post  model with a  User  (the\nauthor), and also your  Post  model may have many  Comments  linked with it.",
            "title": "Working with Related Models"
        },
        {
            "location": "/models/related_data/#defining-relationships",
            "text": "RevJS currently has two types of relational fields:   A  RelatedModel  field is a\n  link from the current model to  one record from another model . In the\n   Post  example above, you would add a  @RelatedModel()  field for the\n   user  field.  A  RelatedModelList \n  field allows access to  a list of records from another model , that are\n  linked to the current one via a RelatedModel field. In the  Post  example\n  above, you would add a  @RelatedModelList()  field for the  comments  field.   Lets implement the  Post ,  User ,  Comments  example to show how these\nfields work:   A  User  can have a  list of Posts  and a  list of Comments  A  Post  is linked to a single  User . and can have a  list of Comments  A  Comment  is linked to a single  User  and a single  Post   \nimport {\n    AutoNumberField, TextField, RelatedModel, RelatedModelList,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\nexport class User {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        username: string;\n    @RelatedModelList({ model: 'Post', field: 'user' })\n        posts: Post[];\n    @RelatedModelList({ model: 'Comment', field: 'user' })\n        comments: Comment[];\n\n    constructor(data?: Partial<User>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'User' })\n        user: User;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @RelatedModelList({ model: 'Comment', field: 'post' })\n        comments: Comment[];\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Comment {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'Post' })\n        post: Post;\n    @RelatedModel({ model: 'User', required: false })\n        user: User;\n    @TextField()\n        comment: string;\n\n    constructor(data?: Partial<Comment>) {\n        Object.assign(this, data);\n    }\n}\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(User);\nmodelManager.register(Post);\nmodelManager.register(Comment);",
            "title": "Defining Relationships"
        },
        {
            "location": "/models/related_data/#creating-related-model-data",
            "text": "As with most RevJS operations, you can create relationships between models\nsimply by assigning values to JavaScript objects as you normally would, then\npassing the resulting object to the create()  or update()  methods of\nyour  ModelManager .  The below example shows how to create a set of related Users, Posts and\nComments:  \nimport { User, Post, Comment, modelManager } from './creating_related_models';\n\nexport async function createData() {\n\n    // Create Users\n\n    const joe = (await modelManager.create(new User({\n        username: 'joe123'\n    }))).result;\n\n    const bill = (await modelManager.create(new User({\n        username: 'bill27'\n    }))).result;\n\n    const jane = (await modelManager.create(new User({\n        username: 'jane12'\n    }))).result;\n\n    // Create Posts\n\n    const post1 = (await modelManager.create(new Post({\n        title: 'Related Data in RevJS',\n        body: 'Pretty easy to do eh?',\n        user: jane\n    }))).result;\n\n    await modelManager.create(new Post({\n        title: 'The Rain in Spain',\n        body: 'Really is a pain?',\n        user: jane\n    }));\n\n    // Create Comments\n\n    await modelManager.create(new Comment({\n        comment: 'True!',\n        post: post1,\n        user: bill\n    }));\n\n    await modelManager.create(new Comment({\n        comment: 'Hmmm, but I reeeeaally like writing SQL...',\n        post: post1,\n        user: joe\n    }));",
            "title": "Creating Related Model Data"
        },
        {
            "location": "/models/related_data/#reading-related-model-data",
            "text": "By default, RevJS will NOT return related model information (for performance\nreasons). However, it is easy to request this data using the  related  option\nfor the ModelManager.read()  method.  See below examples for how to read related model data:  \nimport { Post, modelManager } from './creating_related_models';\nimport { createData } from './creating_related_data';\n\n(async () => {\n    await createData();\n\n    // Read all posts (without related data)\n    const plainPosts = await modelManager.read(Post);\n    console.log('Plain posts:', plainPosts.results);\n\n    // Read all posts, including the 'user' field\n    const posts2 = await modelManager.read(Post, {\n        related: ['user']\n    });\n    console.log('Posts with User:', posts2.results);\n\n    // Read all posts, including the 'user' and 'comments'\n    const posts3 = await modelManager.read(Post, {\n        related: ['user', 'comments']\n    });\n    console.log('Posts with User and Comments:', posts3.results);\n\n    // Read all posts, including the 'user', 'comments' and 'comments.user'\n    const posts4 = await modelManager.read(Post, {\n        related: ['user', 'comments.user']\n    });\n    console.log('Posts with User, Comments and Comment Author:', posts4.results);\n\n})()",
            "title": "Reading Related Model Data"
        },
        {
            "location": "/models/related_data/#updating-related-model-records",
            "text": "You can change the record linked to a RevJS model simply by attaching a\ndifferent model instance, or setting the value to  null , as shown in the\nexamples below:  \nimport { User, Post, Comment, modelManager } from './creating_related_models';\nimport { createData } from './creating_related_data';\n\n(async () => {\n    await createData();\n\n    // Get the first post\n    const post1 = (await modelManager.read(Post, { limit: 1 })).results[0];\n\n    // Get the first user\n    const user1 = (await modelManager.read(User, { limit: 1 })).results[0];\n\n    // Make user1 the author of post1\n    post1.user = user1;\n    await modelManager.update(post1);\n\n    // If we know the ID of the record we want to link, we can pass a new\n    // model instance containing the related ID:\n    post1.user = new User({ id: 2 });\n    await modelManager.update(post1);\n\n    // To un-link a model, set the RelatedModel field to null\n    const comment1 = (await modelManager.read(Comment, { limit: 1 })).results[0];\n    comment1.user = null;\n    await modelManager.update(comment1);\n\n})()  NOTE:  - RevJS supports assigning values to  RelatedModel  fields  only  at\nthe moment. Changes to RelatedModelList fields do not get stored\ncurrently.",
            "title": "Updating Related Model Records"
        },
        {
            "location": "/models/related_data/#searching-based-on-related-model-data",
            "text": "RevJS allows you to search records based on the Primary Key values stored in\nRelatedModel fields. For example:  // Retrieve all comments linked to User id = 1\nmodelManager.read(Comment, {\n    where: {\n        user: 1\n    }\n})\n\n// Retrieve all comments that are not linked to a user\nmodelManager.read(Comment, {\n    where: {\n        user: null\n    }\n})  RevJS does  not yet  support querying for records based on properties of related\nrecords. For example, the following is  not yet possible , but would be cool:  modelManager.read(User, {\n    where: {\n        'posts.title': { _like: '%fake news%' }\n    }\n})  We hope to implement something like this in the future, and of course welcome\ncontributions from the community! :)",
            "title": "Searching based on Related Model Data"
        },
        {
            "location": "/api/creating_an_api/",
            "text": "Creating a GraphQL API\n\u00b6\n\n\nThe \nrev-api\n module of RevJS allows you to easily make your models available\nover the network, via an automatically-generated GraphQL API.\n\n\n\n\nModels are exposed via the \nModelApiManager.register()\n method, and you can\n  choose to expose all of your models via the API, or just a subset of them.\n\n\nYou can choose which \noperations\n (create, read, update, remove) to allow\n  on your models via the API.\n\n\nYou can also expose some of your \nmodel methods\n as \nGraphQL mutations\n.\n\n\n\n\nRegistering API Models\n\u00b6\n\n\nThe example below shows how to specify the allowed operations for specific\nmodels, and register them with an API:\n\n\n\nimport {\n    AutoNumberField, TextField, RelatedModel, RelatedModelList,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\nimport { ApiOperations } from 'rev-api/lib/decorators';\nimport { ModelApiManager } from 'rev-api';\n\n// Use the @ApiOperations decorator to specify what operations are allowed for each model\n\n@ApiOperations(\n    ['read']\n)\nexport class User {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        username: string;\n    @RelatedModelList({ model: 'Post', field: 'user' })\n        posts: Post[];\n    @RelatedModelList({ model: 'Comment', field: 'user' })\n        comments: Comment[];\n\n    constructor(data?: Partial<User>) {\n        Object.assign(this, data);\n    }\n}\n\n@ApiOperations(\n    ['create', 'read', 'update', 'remove']\n)\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'User' })\n        user: User;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @RelatedModelList({ model: 'Comment', field: 'post' })\n        comments: Comment[];\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n@ApiOperations(\n    ['create', 'read', 'remove']\n)\nexport class Comment {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'Post' })\n        post: Post;\n    @RelatedModel({ model: 'User', required: false })\n        user: User;\n    @TextField()\n        comment: string;\n\n    constructor(data?: Partial<Comment>) {\n        Object.assign(this, data);\n    }\n}\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(User);\nmodelManager.register(Post);\nmodelManager.register(Comment);\n\nexport const api = new ModelApiManager(modelManager);\napi.register(User);\napi.register(Post);\napi.register(Comment)\n\n\n\n\nNOTE:\n The seperate import from \nrev-api/lib/decorators\n is designed so you\ncan share the same model definition between your front and back-end code,\nwithout inadvertently including \nrev-api\n back-end code in your front-end\nbundle.\n\n\nExposing your API via HTTP\n\u00b6\n\n\nAPIs created via \nrev-api\n can be exposed by any web framework that can\nserve \nGraphQL JS\n schemas. A good\nexample is \nApollo GraphQL Server\n\nwhich supports most popular NodeJS Web Frameworks.\n\n\nIn the example below, we use apollo graphql server to serve our API:\n\n\n\nimport * as koa from 'koa';\nimport * as koaRouter from 'koa-router';\nimport * as koaBody from 'koa-bodyparser';\nimport { graphqlKoa, graphiqlKoa } from 'graphql-server-koa';\n\n// Load RevJS API and generate GrapQL Schema\n\nimport { api } from './defining_an_api';\nimport { createData } from './model_data';\n\nconst schema = api.getGraphQLSchema();\n\n// Create Koa & Apollo GraphQL Server\n\nconst app = new koa();\nconst port = 3000;\n\nconst router = new koaRouter();\nrouter.post('/graphql', graphqlKoa({ schema: schema }));\nrouter.get('/graphql', graphqlKoa({ schema: schema }));\nrouter.get('/graphiql', graphiqlKoa({ endpointURL: '/graphql' }));\n\napp.use(koaBody());\napp.use(router.routes());\napp.use(router.allowedMethods());\n\napp.listen(port);\n\nconsole.log(`GraphQL Server is running on port ${port}.`);\nconsole.log(`GraphiQL UI is running at http://localhost:${port}/graphiql`);\n\n// Load sample data\n\ncreateData()\n.then(() => {\n    console.log('Data Loaded.');\n})\n.catch((e) => {\n    console.error('Error loading data', e);\n})\n\n\n\n\nGraphQL Query Schema\n\u00b6\n\n\nThe GraphQL \nquery {}\n schema lets you read models and fields in a hierarchical\nway.\n\n\n\n\nRevJS generates a top-level Query object for each model you expose for\n  \nread\n access\n\n\nYou can use the standard \nread()\n function options (\nwhere\n, \nlimit\n,\n \noffset\n and \norderBy\n) when querying the top-level Query objects\n\n\nQuery objects contain a \nresults\n key, containing the matching models, and\n  a \nmeta\n key, containing the current \nlimit\n, \noffset\n and \ntotalCount\n values.\n\n\nRevJS respects the \nRelatedModel\n and \nRelatedModelList\n fields you define\n  on your models, and you can drill-down on these fields to any level in your\n  GraphQL query.\n\n\n\n\nThe screenshot below shows the GraphQL Query Schema generated from the examples\nabove:\n\n\n\n\nGraphQL Mutation Schema\n\u00b6\n\n\nThe GraphQL \nmutation {}\n schema provides access to \ncreate()\n, \nupdate()\n and\n\nremove()\n functions, for all models you have enabled these for. Any\ncustom API Methods you have created will also be available here.\n\n\nThe screenshot below shows the GraphQL Mutation Schema generated from the\nexamples above:\n\n\n\n\nSecurity\n\u00b6\n\n\nIt is \nvery\n important to consider security when exposing data via an API.\nCurrently you must implement security policies in your models, and at the Web\nServer layer (e.g. by securiing your API with\n\nPassport\n).\n\n\nIn future releases we may implement support for \nmiddleware\n, which could be used\nfor authentication and authorisation, but currently we do not have support for\nthis. Contributions welcome! :)",
            "title": "Creating an API"
        },
        {
            "location": "/api/creating_an_api/#creating-a-graphql-api",
            "text": "The  rev-api  module of RevJS allows you to easily make your models available\nover the network, via an automatically-generated GraphQL API.   Models are exposed via the  ModelApiManager.register()  method, and you can\n  choose to expose all of your models via the API, or just a subset of them.  You can choose which  operations  (create, read, update, remove) to allow\n  on your models via the API.  You can also expose some of your  model methods  as  GraphQL mutations .",
            "title": "Creating a GraphQL API"
        },
        {
            "location": "/api/creating_an_api/#registering-api-models",
            "text": "The example below shows how to specify the allowed operations for specific\nmodels, and register them with an API:  \nimport {\n    AutoNumberField, TextField, RelatedModel, RelatedModelList,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\nimport { ApiOperations } from 'rev-api/lib/decorators';\nimport { ModelApiManager } from 'rev-api';\n\n// Use the @ApiOperations decorator to specify what operations are allowed for each model\n\n@ApiOperations(\n    ['read']\n)\nexport class User {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        username: string;\n    @RelatedModelList({ model: 'Post', field: 'user' })\n        posts: Post[];\n    @RelatedModelList({ model: 'Comment', field: 'user' })\n        comments: Comment[];\n\n    constructor(data?: Partial<User>) {\n        Object.assign(this, data);\n    }\n}\n\n@ApiOperations(\n    ['create', 'read', 'update', 'remove']\n)\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'User' })\n        user: User;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @RelatedModelList({ model: 'Comment', field: 'post' })\n        comments: Comment[];\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n@ApiOperations(\n    ['create', 'read', 'remove']\n)\nexport class Comment {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @RelatedModel({ model: 'Post' })\n        post: Post;\n    @RelatedModel({ model: 'User', required: false })\n        user: User;\n    @TextField()\n        comment: string;\n\n    constructor(data?: Partial<Comment>) {\n        Object.assign(this, data);\n    }\n}\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(User);\nmodelManager.register(Post);\nmodelManager.register(Comment);\n\nexport const api = new ModelApiManager(modelManager);\napi.register(User);\napi.register(Post);\napi.register(Comment)  NOTE:  The seperate import from  rev-api/lib/decorators  is designed so you\ncan share the same model definition between your front and back-end code,\nwithout inadvertently including  rev-api  back-end code in your front-end\nbundle.",
            "title": "Registering API Models"
        },
        {
            "location": "/api/creating_an_api/#exposing-your-api-via-http",
            "text": "APIs created via  rev-api  can be exposed by any web framework that can\nserve  GraphQL JS  schemas. A good\nexample is  Apollo GraphQL Server \nwhich supports most popular NodeJS Web Frameworks.  In the example below, we use apollo graphql server to serve our API:  \nimport * as koa from 'koa';\nimport * as koaRouter from 'koa-router';\nimport * as koaBody from 'koa-bodyparser';\nimport { graphqlKoa, graphiqlKoa } from 'graphql-server-koa';\n\n// Load RevJS API and generate GrapQL Schema\n\nimport { api } from './defining_an_api';\nimport { createData } from './model_data';\n\nconst schema = api.getGraphQLSchema();\n\n// Create Koa & Apollo GraphQL Server\n\nconst app = new koa();\nconst port = 3000;\n\nconst router = new koaRouter();\nrouter.post('/graphql', graphqlKoa({ schema: schema }));\nrouter.get('/graphql', graphqlKoa({ schema: schema }));\nrouter.get('/graphiql', graphiqlKoa({ endpointURL: '/graphql' }));\n\napp.use(koaBody());\napp.use(router.routes());\napp.use(router.allowedMethods());\n\napp.listen(port);\n\nconsole.log(`GraphQL Server is running on port ${port}.`);\nconsole.log(`GraphiQL UI is running at http://localhost:${port}/graphiql`);\n\n// Load sample data\n\ncreateData()\n.then(() => {\n    console.log('Data Loaded.');\n})\n.catch((e) => {\n    console.error('Error loading data', e);\n})",
            "title": "Exposing your API via HTTP"
        },
        {
            "location": "/api/creating_an_api/#graphql-query-schema",
            "text": "The GraphQL  query {}  schema lets you read models and fields in a hierarchical\nway.   RevJS generates a top-level Query object for each model you expose for\n   read  access  You can use the standard  read()  function options ( where ,  limit ,\n  offset  and  orderBy ) when querying the top-level Query objects  Query objects contain a  results  key, containing the matching models, and\n  a  meta  key, containing the current  limit ,  offset  and  totalCount  values.  RevJS respects the  RelatedModel  and  RelatedModelList  fields you define\n  on your models, and you can drill-down on these fields to any level in your\n  GraphQL query.   The screenshot below shows the GraphQL Query Schema generated from the examples\nabove:",
            "title": "GraphQL Query Schema"
        },
        {
            "location": "/api/creating_an_api/#graphql-mutation-schema",
            "text": "The GraphQL  mutation {}  schema provides access to  create() ,  update()  and remove()  functions, for all models you have enabled these for. Any\ncustom API Methods you have created will also be available here.  The screenshot below shows the GraphQL Mutation Schema generated from the\nexamples above:",
            "title": "GraphQL Mutation Schema"
        },
        {
            "location": "/api/creating_an_api/#security",
            "text": "It is  very  important to consider security when exposing data via an API.\nCurrently you must implement security policies in your models, and at the Web\nServer layer (e.g. by securiing your API with Passport ).  In future releases we may implement support for  middleware , which could be used\nfor authentication and authorisation, but currently we do not have support for\nthis. Contributions welcome! :)",
            "title": "Security"
        },
        {
            "location": "/components/rev-models/",
            "text": "rev-models - RevJS Data Models\n\u00b6\n\n\nThe \nrev-models\n module provides the following:\n\n\n\n\nA set of \nBuilt-in Field Types\n for defining your\n   data models\n\n\nA \nModelManager\n object, which holds the list of\n   your registered models, and provides functions for \ncreate\n, \nread\n,\n   \nupdate\n and \ndelete\n.\n\n\nAn \nin-memory\n storage backend, so you can play with RevJS functions without\n   needing to set up a database.\n\n\n\n\nJump to the \nrev-models API Documentation\n\n\nExample\n\u00b6\n\n\nThe example below registers a simple data class with some basic validation\nrules, creates some data, and reads it back.\n\n\n\nimport {\n    AutoNumberField, TextField, SelectField,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define model\n\nconst POST_STATUS = [\n    ['draft', 'Draft'],\n    ['published', 'Published']\n];\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField({ minLength: 5, maxLength: 100 })\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @SelectField({ selection: POST_STATUS })\n        status: string;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n(async () => {\n\n    // Create some data\n\n    await modelManager.create(new Post({\n        title: 'My First Post',\n        body: 'This is a really cool post made in RevJS',\n        status: 'draft'\n    }));\n\n    await modelManager.create(new Post({\n        title: 'RevJS is awesome!',\n        body: 'I should use it for ALL TEH THINGZZZ!',\n        status: 'published'\n    }));\n\n    // Read it back\n\n    const res = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { title: { _like: '%RevJS%' }},\n                { body: { _like: '%RevJS%' }}\n            ]\n        }\n    });\n\n    console.log(res.results);\n\n})();\n\n\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-models"
        },
        {
            "location": "/components/rev-models/#rev-models-revjs-data-models",
            "text": "The  rev-models  module provides the following:   A set of  Built-in Field Types  for defining your\n   data models  A  ModelManager  object, which holds the list of\n   your registered models, and provides functions for  create ,  read ,\n    update  and  delete .  An  in-memory  storage backend, so you can play with RevJS functions without\n   needing to set up a database.   Jump to the  rev-models API Documentation",
            "title": "rev-models - RevJS Data Models"
        },
        {
            "location": "/components/rev-models/#example",
            "text": "The example below registers a simple data class with some basic validation\nrules, creates some data, and reads it back.  \nimport {\n    AutoNumberField, TextField, SelectField,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define model\n\nconst POST_STATUS = [\n    ['draft', 'Draft'],\n    ['published', 'Published']\n];\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField({ minLength: 5, maxLength: 100 })\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @SelectField({ selection: POST_STATUS })\n        status: string;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n(async () => {\n\n    // Create some data\n\n    await modelManager.create(new Post({\n        title: 'My First Post',\n        body: 'This is a really cool post made in RevJS',\n        status: 'draft'\n    }));\n\n    await modelManager.create(new Post({\n        title: 'RevJS is awesome!',\n        body: 'I should use it for ALL TEH THINGZZZ!',\n        status: 'published'\n    }));\n\n    // Read it back\n\n    const res = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { title: { _like: '%RevJS%' }},\n                { body: { _like: '%RevJS%' }}\n            ]\n        }\n    });\n\n    console.log(res.results);\n\n})();",
            "title": "Example"
        },
        {
            "location": "/components/rev-models/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/components/rev-backend-mongodb/",
            "text": "rev-backend-mongodb\n\u00b6\n\n\nrev-backend-mongodb API Documentation\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-backend-mongodb"
        },
        {
            "location": "/components/rev-backend-mongodb/#rev-backend-mongodb",
            "text": "rev-backend-mongodb API Documentation",
            "title": "rev-backend-mongodb"
        },
        {
            "location": "/components/rev-backend-mongodb/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/components/rev-api/",
            "text": "rev-api\n\u00b6\n\n\n// TODO\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-api"
        },
        {
            "location": "/components/rev-api/#rev-api",
            "text": "// TODO",
            "title": "rev-api"
        },
        {
            "location": "/components/rev-api/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/components/rev-api-client/",
            "text": "rev-api-client\n\u00b6\n\n\n// TODO\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-api-client"
        },
        {
            "location": "/components/rev-api-client/#rev-api-client",
            "text": "// TODO",
            "title": "rev-api-client"
        },
        {
            "location": "/components/rev-api-client/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/components/rev-ui/",
            "text": "rev-ui\n\u00b6\n\n\n// TODO\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-ui"
        },
        {
            "location": "/components/rev-ui/#rev-ui",
            "text": "// TODO",
            "title": "rev-ui"
        },
        {
            "location": "/components/rev-ui/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/changelog/",
            "text": "Change Log\n\u00b6\n\n\nRevJS Module Releases\n\u00b6\n\n\n0.12.0 - 11th March 2018\n\u00b6\n\n\nrev-api\n\n\n\n\nImprove error when a GraphQL fieldMapping is not found for a field type\n\n\nFix GraphQL mappings for EmailField, URLField and PasswordField\n\n\n\n\nrev-api-client\n\n\n\n\nFix error when model fields are null\n\n\n\n\nrev-ui\n\n\n\n\nAdded viewContext.remove() method. We now have full CRUD :)\n\n\nAdded \n<RemoveAction />\n component for removing the current record in a \n<DetailView />\n\n\nAll Action components now have default labels\n\n\nStarted work on UI demos in \npackages/examples/src/creating_a_ui\n\n\n\n\n0.11.0 - 8th March 2018\n\u00b6\n\n\n\n\nFirst public release of \nrev-backend-mongodb\n. Passes full backend test suite\n\n\nDocs and guides updated\n\n\n\n\n0.10.0 - 3rd March 2018\n\u00b6\n\n\n\n\nRemove unnecessary \nIModelValidationResult.validationFinished\n property\n\n\nDocs updates\n\n\n\n\n0.9.1 - 3rd March 2018\n\u00b6\n\n\n\n\nDocs update\n\n\nMark some module internals as @privat",
            "title": "Change Log"
        },
        {
            "location": "/changelog/#change-log",
            "text": "",
            "title": "Change Log"
        },
        {
            "location": "/changelog/#revjs-module-releases",
            "text": "",
            "title": "RevJS Module Releases"
        },
        {
            "location": "/changelog/#0120-11th-march-2018",
            "text": "rev-api   Improve error when a GraphQL fieldMapping is not found for a field type  Fix GraphQL mappings for EmailField, URLField and PasswordField   rev-api-client   Fix error when model fields are null   rev-ui   Added viewContext.remove() method. We now have full CRUD :)  Added  <RemoveAction />  component for removing the current record in a  <DetailView />  All Action components now have default labels  Started work on UI demos in  packages/examples/src/creating_a_ui",
            "title": "0.12.0 - 11th March 2018"
        },
        {
            "location": "/changelog/#0110-8th-march-2018",
            "text": "First public release of  rev-backend-mongodb . Passes full backend test suite  Docs and guides updated",
            "title": "0.11.0 - 8th March 2018"
        },
        {
            "location": "/changelog/#0100-3rd-march-2018",
            "text": "Remove unnecessary  IModelValidationResult.validationFinished  property  Docs updates",
            "title": "0.10.0 - 3rd March 2018"
        },
        {
            "location": "/changelog/#091-3rd-march-2018",
            "text": "Docs update  Mark some module internals as @privat",
            "title": "0.9.1 - 3rd March 2018"
        }
    ]
}