{
    "docs": [
        {
            "location": "/",
            "text": "RevJS - Rev up your data-driven JS app development!\n\u00b6\n\n\nWhat is RevJS?\n\u00b6\n\n\nRevJS is a suite of JavaScript modules designed to speed up development of\ndata-driven JS applications.\n\n\nRevJS allows you to\n\n\n\n\nDefine a relational \ndata model\n using plain JS classes, and built-in or custom field types\n\n\nDefine custom \nvalidation logic\n directly in your models\n\n\nEasily create a \nGraphQL API\n to make your models available over the network\n\n\nQuickly build a \nuser interface\n for the web or mobile, using our React higher-order components\n\n\n\n\nExample\n\u00b6\n\n\nThe below example shows how to create a simple data model with RevJS's \nrev-models\n module:\n\n\n\nimport {\n    AutoNumberField, TextField, SelectField, IntegerField,\n    RelatedModel, ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define models\n\nexport class City {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        name: string;\n\n    constructor(data?: Partial<City>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Customer {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        first_name: string;\n    @TextField()\n        last_name: string;\n    @IntegerField()\n        age: number;\n    @SelectField({ selection: [['M', 'Male'], ['F', 'Female']] })\n        gender: string;\n    @RelatedModel({ model: 'City', required: false })\n        city: City;\n\n    constructor(data?: Partial<Customer>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager and register the models\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\n\nmodelManager.register(City);\nmodelManager.register(Customer);\n\n\n\n\nResJS is designed for use with \nTypeScript\n, to give you all the\nbenefits of strong typing and intellisense, however it should work with\nstandard ES6+ too. (we're looking for someone interested in creating and\nmaintaining a revjs ES6+ guide!...)\n\n\nComponents\n\u00b6\n\n\nrev-models\n\u00b6\n\n\nDefine your Data Models and Validation, and easily test them out with the in-memory\nstorage provided.\n\n\nrev-api\n\u00b6\n\n\nExpose your data model via an automatically-generated GraphQL API\n\n\nrev-api-client\n\u00b6\n\n\nAccess your server-side models in the browser or on a mobile device,\nusing the same API and validation logic.\n\n\nrev-ui\n\u00b6\n\n\nQuickly build user interfaces with data from your RevJS backend using our\nReact higher-order components.\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!\n\n\nLicense\n\u00b6\n\n\nMIT",
            "title": "Welcome to RevJS!"
        },
        {
            "location": "/#revjs-rev-up-your-data-driven-js-app-development",
            "text": "",
            "title": "RevJS - Rev up your data-driven JS app development!"
        },
        {
            "location": "/#what-is-revjs",
            "text": "RevJS is a suite of JavaScript modules designed to speed up development of\ndata-driven JS applications.  RevJS allows you to   Define a relational  data model  using plain JS classes, and built-in or custom field types  Define custom  validation logic  directly in your models  Easily create a  GraphQL API  to make your models available over the network  Quickly build a  user interface  for the web or mobile, using our React higher-order components",
            "title": "What is RevJS?"
        },
        {
            "location": "/#example",
            "text": "The below example shows how to create a simple data model with RevJS's  rev-models  module:  \nimport {\n    AutoNumberField, TextField, SelectField, IntegerField,\n    RelatedModel, ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define models\n\nexport class City {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        name: string;\n\n    constructor(data?: Partial<City>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Customer {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        first_name: string;\n    @TextField()\n        last_name: string;\n    @IntegerField()\n        age: number;\n    @SelectField({ selection: [['M', 'Male'], ['F', 'Female']] })\n        gender: string;\n    @RelatedModel({ model: 'City', required: false })\n        city: City;\n\n    constructor(data?: Partial<Customer>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager and register the models\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\n\nmodelManager.register(City);\nmodelManager.register(Customer);  ResJS is designed for use with  TypeScript , to give you all the\nbenefits of strong typing and intellisense, however it should work with\nstandard ES6+ too. (we're looking for someone interested in creating and\nmaintaining a revjs ES6+ guide!...)",
            "title": "Example"
        },
        {
            "location": "/#components",
            "text": "",
            "title": "Components"
        },
        {
            "location": "/#rev-models",
            "text": "Define your Data Models and Validation, and easily test them out with the in-memory\nstorage provided.",
            "title": "rev-models"
        },
        {
            "location": "/#rev-api",
            "text": "Expose your data model via an automatically-generated GraphQL API",
            "title": "rev-api"
        },
        {
            "location": "/#rev-api-client",
            "text": "Access your server-side models in the browser or on a mobile device,\nusing the same API and validation logic.",
            "title": "rev-api-client"
        },
        {
            "location": "/#rev-ui",
            "text": "Quickly build user interfaces with data from your RevJS backend using our\nReact higher-order components.",
            "title": "rev-ui"
        },
        {
            "location": "/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/#license",
            "text": "MIT",
            "title": "License"
        },
        {
            "location": "/models/creating_models/",
            "text": "Creating your Data Model\n\u00b6\n\n\nDefining Models\n\u00b6\n\n\nA \"Model\" in RevJS is simply a JavaScript Class with some additional properties\nthat tell RevJS how to validate, store and retrieve data.\n\n\nIf you are using \nTypeScript\n, then you can use decorators to easily define\nthe properties of your model.\n\n\nIn order to use your model classes, you must register them using the\n\nregister()\n method of a\n\nModelManager\n instance.\n\n\nThe example below shows how to create two related models, and register them\nwith a ModelManager:\n\n\n\nimport {\n    AutoNumberField, TextField, SelectField, IntegerField,\n    RelatedModel, ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define models\n\nexport class City {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        name: string;\n\n    constructor(data?: Partial<City>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Customer {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        first_name: string;\n    @TextField()\n        last_name: string;\n    @IntegerField()\n        age: number;\n    @SelectField({ selection: [['M', 'Male'], ['F', 'Female']] })\n        gender: string;\n    @RelatedModel({ model: 'City', required: false })\n        city: City;\n\n    constructor(data?: Partial<Customer>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager and register the models\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\n\nmodelManager.register(City);\nmodelManager.register(Customer);\n\n\n\n\nBuilt-in Field Types\n\u00b6\n\n\nRevJS ships with a set 15 standard field types, and you can also create your own\nby extending the \nField\n class.\n\n\n\n\nTextField\n - Single, or multi-line text field\n\n\nEmailField\n - TextField with e-mail address validation\n\n\nUrlField\n - TextField with URL validation\n\n\nPasswordField\n - Password field\n\n\nNumberField\n - Number entry field (any numeric value)\n\n\nIntegerField\n - Integer entry field\n\n\nAutoNumberField\n - Auto-generated, sequential integer field\n\n\nBooleanField\n - True / false\n\n\nSelectField\n - Single-item selection field\n\n\nMultiSelectField\n - Multiple-item selection field\n\n\nDateField\n - Date-only field\n\n\nTimeField\n - Time-only field\n\n\nDateTimeField\n - Date & Time field\n\n\nRelatedModelField\n - Foreign-key link to a related model\n\n\nRelatedModelListField\n - List of related models\n\n\n\n\nValidation\n\u00b6\n\n\nIn addition to the built-in, configurable validation provided by fields, you\ncan specify your own validation logic directly on your models by defining a\n\nvalidate()\n or \nvalidateAsync()\n method, as shown in the\nexample below:\n\n\n\nimport {\n    AutoNumberField, TextField, BooleanField,\n    ModelManager, InMemoryBackend, IValidationContext\n} from 'rev-models';\n\n// Define model with some custom validation\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @BooleanField()\n        is_published: boolean;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n\n    // Define synchronous validation\n    validate(ctx: IValidationContext) {\n        if (this.body.includes('fake news')) {\n            ctx.result.addFieldError('body', 'Body must not contain fake news!');\n        }\n    }\n\n    // Define some asynchronous validation\n    async validateAsync(ctx: IValidationContext) {\n        if (ctx.operation.operationName == 'create') {\n            const duplicates = await ctx.manager.read(Post, {\n                where: {\n                    title: { _like: this.title }\n                }\n            });\n            if (duplicates.meta.totalCount > 0) {\n                ctx.result.addFieldError('title', 'Cannot create post with a duplicate title!');\n            }\n        }\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n// Create some data\n\n(async () => {\n    try {\n\n        // Create a valid post\n        await modelManager.create(new Post({\n            title: 'This is a valid post',\n            body: 'No alternative facts here!',\n            is_published: true\n        }));\n\n        // Try to create a duplicate post...\n        await modelManager.create(new Post({\n            title: 'This is a valid post',\n            body: 'Not really! Its a duplicate, so should cause an error...',\n            is_published: true\n        }));\n\n    }\n    catch (e) {\n        console.error(e.message);\n    }\n})();\n\n\n\n\nThe output of the above code is:\n\n\nValidationError\n * title: Cannot create post with a duplicate title!\n\n\n\n\nFor further information on model validation functions, check out the\n\nIModel\n interface\n\n\nRevJS Backends\n\u00b6\n\n\nRevJS has the concept of a \npluggable backend architecture\n, to allow it to\nsupport storage of models in a variety of databases and across the network\nusing APIs. The following backends are currently available:\n\n\n\n\nInMemoryBackend\n - stores your\n   model data in-memory. Ideal for initial development and automated testing.\n\n\nModelApiBackend\n - designed for use in the browser or a mobile app.\n   Uses the API created by \nrev-api\n to store and retrieve your models.\n\n\nMongoDBBackend\n - stores and retrieves your data from MongoDB\n\n\n\n\nWe have defined a standard \nIBackend\n\ninterface, as well as a\n\nStandard Test Suite\n\nto aid with new backend development, and are keen to accept any contributions\nfrom the community!",
            "title": "Creating Models"
        },
        {
            "location": "/models/creating_models/#creating-your-data-model",
            "text": "",
            "title": "Creating your Data Model"
        },
        {
            "location": "/models/creating_models/#defining-models",
            "text": "A \"Model\" in RevJS is simply a JavaScript Class with some additional properties\nthat tell RevJS how to validate, store and retrieve data.  If you are using  TypeScript , then you can use decorators to easily define\nthe properties of your model.  In order to use your model classes, you must register them using the register()  method of a ModelManager  instance.  The example below shows how to create two related models, and register them\nwith a ModelManager:  \nimport {\n    AutoNumberField, TextField, SelectField, IntegerField,\n    RelatedModel, ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define models\n\nexport class City {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        name: string;\n\n    constructor(data?: Partial<City>) {\n        Object.assign(this, data);\n    }\n}\n\nexport class Customer {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        first_name: string;\n    @TextField()\n        last_name: string;\n    @IntegerField()\n        age: number;\n    @SelectField({ selection: [['M', 'Male'], ['F', 'Female']] })\n        gender: string;\n    @RelatedModel({ model: 'City', required: false })\n        city: City;\n\n    constructor(data?: Partial<Customer>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager and register the models\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\n\nmodelManager.register(City);\nmodelManager.register(Customer);",
            "title": "Defining Models"
        },
        {
            "location": "/models/creating_models/#built-in-field-types",
            "text": "RevJS ships with a set 15 standard field types, and you can also create your own\nby extending the  Field  class.   TextField  - Single, or multi-line text field  EmailField  - TextField with e-mail address validation  UrlField  - TextField with URL validation  PasswordField  - Password field  NumberField  - Number entry field (any numeric value)  IntegerField  - Integer entry field  AutoNumberField  - Auto-generated, sequential integer field  BooleanField  - True / false  SelectField  - Single-item selection field  MultiSelectField  - Multiple-item selection field  DateField  - Date-only field  TimeField  - Time-only field  DateTimeField  - Date & Time field  RelatedModelField  - Foreign-key link to a related model  RelatedModelListField  - List of related models",
            "title": "Built-in Field Types"
        },
        {
            "location": "/models/creating_models/#validation",
            "text": "In addition to the built-in, configurable validation provided by fields, you\ncan specify your own validation logic directly on your models by defining a validate()  or  validateAsync()  method, as shown in the\nexample below:  \nimport {\n    AutoNumberField, TextField, BooleanField,\n    ModelManager, InMemoryBackend, IValidationContext\n} from 'rev-models';\n\n// Define model with some custom validation\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @BooleanField()\n        is_published: boolean;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n\n    // Define synchronous validation\n    validate(ctx: IValidationContext) {\n        if (this.body.includes('fake news')) {\n            ctx.result.addFieldError('body', 'Body must not contain fake news!');\n        }\n    }\n\n    // Define some asynchronous validation\n    async validateAsync(ctx: IValidationContext) {\n        if (ctx.operation.operationName == 'create') {\n            const duplicates = await ctx.manager.read(Post, {\n                where: {\n                    title: { _like: this.title }\n                }\n            });\n            if (duplicates.meta.totalCount > 0) {\n                ctx.result.addFieldError('title', 'Cannot create post with a duplicate title!');\n            }\n        }\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n// Create some data\n\n(async () => {\n    try {\n\n        // Create a valid post\n        await modelManager.create(new Post({\n            title: 'This is a valid post',\n            body: 'No alternative facts here!',\n            is_published: true\n        }));\n\n        // Try to create a duplicate post...\n        await modelManager.create(new Post({\n            title: 'This is a valid post',\n            body: 'Not really! Its a duplicate, so should cause an error...',\n            is_published: true\n        }));\n\n    }\n    catch (e) {\n        console.error(e.message);\n    }\n})();  The output of the above code is:  ValidationError\n * title: Cannot create post with a duplicate title!  For further information on model validation functions, check out the IModel  interface",
            "title": "Validation"
        },
        {
            "location": "/models/creating_models/#revjs-backends",
            "text": "RevJS has the concept of a  pluggable backend architecture , to allow it to\nsupport storage of models in a variety of databases and across the network\nusing APIs. The following backends are currently available:   InMemoryBackend  - stores your\n   model data in-memory. Ideal for initial development and automated testing.  ModelApiBackend  - designed for use in the browser or a mobile app.\n   Uses the API created by  rev-api  to store and retrieve your models.  MongoDBBackend  - stores and retrieves your data from MongoDB   We have defined a standard  IBackend \ninterface, as well as a Standard Test Suite \nto aid with new backend development, and are keen to accept any contributions\nfrom the community!",
            "title": "RevJS Backends"
        },
        {
            "location": "/models/creating_data/",
            "text": "Creating Model Data\n\u00b6\n\n\nSince RevJS models are just JavaScript classes, you create new records by\ncreating new instances of your model class, and passing them to the\n\nModelManager.create()\n\nmethod.\n\n\nDefining Model Constructors\n\u00b6\n\n\nTo make it easier to populate new records, we recommend adding a constructor\nfunction to your class, as shown in the example below:\n\n\nclass MyCoolModel {\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n\n    constructor(data?: Partial<MyCoolModel>) {\n        Object.assign(this, data);\n    }\n}\n\n\n\n\nDoing this means you can then construct new records with new data in a single\nstatement, as shown below:\n\n\nconst new_record = new MyCoolModel({\n    title: 'New Record',\n    body: 'This is a cool new record with some data!'\n});\n\n\n\n\nIMPORTANT NOTE:\n It should also be possible to construct instances\nof your model \nwithout\n passing any data. RevJS needs to do this when\nhydrating models from data retrieved from a backend.\n\n\nStoring Model Data\n\u00b6\n\n\nTo store data for your model in a backend, simply pass a populated instance\nof your model to the\n\nModelManager.create()\n\nmethod.\n\n\nThe model data will be validated before it is passed to the backend. If any\nvalidation errors occur, a\n\nValidationError\n will be\nthrown.\n\n\nThe example below shows how to define a model and create some data for it:\n\n\n\nimport {\n    AutoNumberField, TextField, SelectField,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define model\n\nconst POST_STATUS = [\n    ['draft', 'Draft'],\n    ['published', 'Published']\n];\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField({ minLength: 5, maxLength: 100 })\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @SelectField({ selection: POST_STATUS })\n        status: string;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n(async () => {\n\n    // Create some data\n\n    await modelManager.create(new Post({\n        title: 'My First Post',\n        body: 'This is a really cool post made in RevJS',\n        status: 'draft'\n    }));\n\n    await modelManager.create(new Post({\n        title: 'RevJS is awesome!',\n        body: 'I should use it for ALL TEH THINGZZZ!',\n        status: 'published'\n    }));\n\n    // Read it back\n\n    const res = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { title: { _like: '%RevJS%' }},\n                { body: { _like: '%RevJS%' }}\n            ]\n        }\n    });\n\n    console.log(res.results);\n\n})();",
            "title": "Creating Model Data"
        },
        {
            "location": "/models/creating_data/#creating-model-data",
            "text": "Since RevJS models are just JavaScript classes, you create new records by\ncreating new instances of your model class, and passing them to the ModelManager.create() \nmethod.",
            "title": "Creating Model Data"
        },
        {
            "location": "/models/creating_data/#defining-model-constructors",
            "text": "To make it easier to populate new records, we recommend adding a constructor\nfunction to your class, as shown in the example below:  class MyCoolModel {\n    @TextField()\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n\n    constructor(data?: Partial<MyCoolModel>) {\n        Object.assign(this, data);\n    }\n}  Doing this means you can then construct new records with new data in a single\nstatement, as shown below:  const new_record = new MyCoolModel({\n    title: 'New Record',\n    body: 'This is a cool new record with some data!'\n});  IMPORTANT NOTE:  It should also be possible to construct instances\nof your model  without  passing any data. RevJS needs to do this when\nhydrating models from data retrieved from a backend.",
            "title": "Defining Model Constructors"
        },
        {
            "location": "/models/creating_data/#storing-model-data",
            "text": "To store data for your model in a backend, simply pass a populated instance\nof your model to the ModelManager.create() \nmethod.  The model data will be validated before it is passed to the backend. If any\nvalidation errors occur, a ValidationError  will be\nthrown.  The example below shows how to define a model and create some data for it:  \nimport {\n    AutoNumberField, TextField, SelectField,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define model\n\nconst POST_STATUS = [\n    ['draft', 'Draft'],\n    ['published', 'Published']\n];\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField({ minLength: 5, maxLength: 100 })\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @SelectField({ selection: POST_STATUS })\n        status: string;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n(async () => {\n\n    // Create some data\n\n    await modelManager.create(new Post({\n        title: 'My First Post',\n        body: 'This is a really cool post made in RevJS',\n        status: 'draft'\n    }));\n\n    await modelManager.create(new Post({\n        title: 'RevJS is awesome!',\n        body: 'I should use it for ALL TEH THINGZZZ!',\n        status: 'published'\n    }));\n\n    // Read it back\n\n    const res = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { title: { _like: '%RevJS%' }},\n                { body: { _like: '%RevJS%' }}\n            ]\n        }\n    });\n\n    console.log(res.results);\n\n})();",
            "title": "Storing Model Data"
        },
        {
            "location": "/models/reading_data/",
            "text": "Reading Model Data\n\u00b6\n\n\nOnce you have defined your models and created some data, you can read it back\nusing the\n\nModelManager.read()\n method.\n\n\nReading All Data\n\u00b6\n\n\nTo read all model data without applying any filters, simply pass the model\nclass to your ModelManager's \nread()\n function:\n\n\n\nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    const res = await modelManager.read(Post);\n\n    for (let post of res.results) {\n        console.log(post.title);\n    }\n})();\n\n\n\n\nIMPORTANT NOTE:\n To encourage use of paging, the \nread()\n function will\nonly return \nthe first 20 records\n by default. See below for how to use the\n\nlimit\n and \noffset\n options to \npage\n through the data.\n\n\nSearching for Data\n\u00b6\n\n\nRevJS uses a MongoDB-like query language for building search queries. Below are\nsome examples:\n\n\n\nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Find all posts in the 'technology' category that are published\n    const techPosts = await modelManager.read(Post, {\n        where: {\n            category: 'technology',\n            published: true\n        }\n    });\n    console.log('Tech Posts:', techPosts.results);\n\n    // Find all published posts in the 'science' OR 'technology' categories\n    const sciTechPosts = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { category: 'science' },\n                { category: 'technology' }\n            ],\n            published: true\n        }\n    });\n    console.log('Science & Technology Posts:', sciTechPosts.results);\n\n    // Find all posts with a rating greater than or equal to 3\n    const goodPosts = await modelManager.read(Post, {\n        where: {\n            rating: { _gte: 3 }\n        }\n    });\n    console.log('Good Posts:', goodPosts.results);\n\n})();\n\n\n\n\nRevJS Query Operators\n\u00b6\n\n\nLogical Operators\n\u00b6\n\n\nThese operators take an array of conditions (as per the \n_or\n example above).\n\n\n\n\n_and\n - all conditions in the array must be true\n\n\n_or\n - at least one of the conditions in the array must be true\n\n\n\n\nValue Operators\n\u00b6\n\n\nThese operators take a single value (as per the \n_gte\n example above).\n\n\n\n\n_eq\n - equals - field must exactly match the specified value\n\n\n_neq\n - not equals - field must not match the specified value\n\n\n_gt\n - greater than - field must be greater than the specified value\n\n\n_gte\n - greater than or equal to - field must be greater than or equal to the specified value\n\n\n_lt\n - less than - field must be less than the specified value\n\n\n_lte\n - less than or equal to - field must be less than or equal to the specified value\n\n\n_like\n - like - field must be like the specified value, which can include \n%\n symbols to match multiple characters (works as per the traditional SQL 'LIKE' clause)\n\n\n\n\nValue List Operators\n\u00b6\n\n\nThese operators take an array of values.\n\n\n\n\n_in\n - in - field must match one of the values in the array\n\n\n_nin\n - not in - field must not match any of the values in the array\n\n\n\n\nUsing \nlimit\n and \noffset\n\u00b6\n\n\nYou can use the \nlimit\n and \noffset\n options with the\n\nread()\n method, to\n\npage\n through query results, as shown in the examples below:\n\n\n\nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Get the first 3 published posts\n    const first3Posts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        offset: 0,\n        limit: 3\n    });\n    console.log('First 3 Published Posts:', first3Posts.results);\n\n    // Get the next 3 published posts\n    const next3Posts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        offset: 3,\n        limit: 3\n    });\n    console.log('Next 3 Posts:', next3Posts.results);\n\n    // Just get all the published posts (max 100)\n    const allPosts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        limit: 100\n    });\n    console.log('All Teh Posts:', allPosts.results);\n\n})();\n\n\n\n\nSorting Data\n\u00b6\n\n\nYou can use the \norderBy\n option to specify the order of the records that are\nretrieved from the backend. This option takes an array of field names, and the\nrecords are sorted by each of the specified fields, in order. You can optionally\nuse the \ndesc\n keyword after the field name, to sort the values in that field\nin descending order.\n\n\n\nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Read all published posts, sorted by Title\n    const postsByTitle = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        limit: 100,\n        orderBy: ['title']\n    });\n    console.log('Posts by Title:', postsByTitle.results);\n\n    // Read all posts, sorted by Title in descending order\n    const postsByTitleDesc = await modelManager.read(Post, {\n        limit: 100,\n        orderBy: ['title desc']\n    });\n    console.log('Posts by Titie in descending order:', postsByTitleDesc.results);\n\n    // Read the first 10 posts sorted by Rating, then by Title\n    const top10Posts = await modelManager.read(Post, {\n        limit: 10,\n        orderBy: ['rating desc', 'title']\n    });\n    console.log('Top Posts:', top10Posts.results);\n\n})();",
            "title": "Reading Model Data"
        },
        {
            "location": "/models/reading_data/#reading-model-data",
            "text": "Once you have defined your models and created some data, you can read it back\nusing the ModelManager.read()  method.",
            "title": "Reading Model Data"
        },
        {
            "location": "/models/reading_data/#reading-all-data",
            "text": "To read all model data without applying any filters, simply pass the model\nclass to your ModelManager's  read()  function:  \nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    const res = await modelManager.read(Post);\n\n    for (let post of res.results) {\n        console.log(post.title);\n    }\n})();  IMPORTANT NOTE:  To encourage use of paging, the  read()  function will\nonly return  the first 20 records  by default. See below for how to use the limit  and  offset  options to  page  through the data.",
            "title": "Reading All Data"
        },
        {
            "location": "/models/reading_data/#searching-for-data",
            "text": "RevJS uses a MongoDB-like query language for building search queries. Below are\nsome examples:  \nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Find all posts in the 'technology' category that are published\n    const techPosts = await modelManager.read(Post, {\n        where: {\n            category: 'technology',\n            published: true\n        }\n    });\n    console.log('Tech Posts:', techPosts.results);\n\n    // Find all published posts in the 'science' OR 'technology' categories\n    const sciTechPosts = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { category: 'science' },\n                { category: 'technology' }\n            ],\n            published: true\n        }\n    });\n    console.log('Science & Technology Posts:', sciTechPosts.results);\n\n    // Find all posts with a rating greater than or equal to 3\n    const goodPosts = await modelManager.read(Post, {\n        where: {\n            rating: { _gte: 3 }\n        }\n    });\n    console.log('Good Posts:', goodPosts.results);\n\n})();",
            "title": "Searching for Data"
        },
        {
            "location": "/models/reading_data/#revjs-query-operators",
            "text": "",
            "title": "RevJS Query Operators"
        },
        {
            "location": "/models/reading_data/#logical-operators",
            "text": "These operators take an array of conditions (as per the  _or  example above).   _and  - all conditions in the array must be true  _or  - at least one of the conditions in the array must be true",
            "title": "Logical Operators"
        },
        {
            "location": "/models/reading_data/#value-operators",
            "text": "These operators take a single value (as per the  _gte  example above).   _eq  - equals - field must exactly match the specified value  _neq  - not equals - field must not match the specified value  _gt  - greater than - field must be greater than the specified value  _gte  - greater than or equal to - field must be greater than or equal to the specified value  _lt  - less than - field must be less than the specified value  _lte  - less than or equal to - field must be less than or equal to the specified value  _like  - like - field must be like the specified value, which can include  %  symbols to match multiple characters (works as per the traditional SQL 'LIKE' clause)",
            "title": "Value Operators"
        },
        {
            "location": "/models/reading_data/#value-list-operators",
            "text": "These operators take an array of values.   _in  - in - field must match one of the values in the array  _nin  - not in - field must not match any of the values in the array",
            "title": "Value List Operators"
        },
        {
            "location": "/models/reading_data/#using-limit-and-offset",
            "text": "You can use the  limit  and  offset  options with the read()  method, to page  through query results, as shown in the examples below:  \nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Get the first 3 published posts\n    const first3Posts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        offset: 0,\n        limit: 3\n    });\n    console.log('First 3 Published Posts:', first3Posts.results);\n\n    // Get the next 3 published posts\n    const next3Posts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        offset: 3,\n        limit: 3\n    });\n    console.log('Next 3 Posts:', next3Posts.results);\n\n    // Just get all the published posts (max 100)\n    const allPosts = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        limit: 100\n    });\n    console.log('All Teh Posts:', allPosts.results);\n\n})();",
            "title": "Using limit and offset"
        },
        {
            "location": "/models/reading_data/#sorting-data",
            "text": "You can use the  orderBy  option to specify the order of the records that are\nretrieved from the backend. This option takes an array of field names, and the\nrecords are sorted by each of the specified fields, in order. You can optionally\nuse the  desc  keyword after the field name, to sort the values in that field\nin descending order.  \nimport { Post, modelManager, createData } from './models';\n\n(async () => {\n    await createData();\n\n    // Read all published posts, sorted by Title\n    const postsByTitle = await modelManager.read(Post, {\n        where: {\n            published: true\n        },\n        limit: 100,\n        orderBy: ['title']\n    });\n    console.log('Posts by Title:', postsByTitle.results);\n\n    // Read all posts, sorted by Title in descending order\n    const postsByTitleDesc = await modelManager.read(Post, {\n        limit: 100,\n        orderBy: ['title desc']\n    });\n    console.log('Posts by Titie in descending order:', postsByTitleDesc.results);\n\n    // Read the first 10 posts sorted by Rating, then by Title\n    const top10Posts = await modelManager.read(Post, {\n        limit: 10,\n        orderBy: ['rating desc', 'title']\n    });\n    console.log('Top Posts:', top10Posts.results);\n\n})();",
            "title": "Sorting Data"
        },
        {
            "location": "/models/updating_data/",
            "text": "Updating Model Data\n\u00b6\n\n\nYou can update records using the\n\nModelManager.update()\n\nmethod. There are a couple of ways to use it:\n\n\nUpdating Data from Reads\n\u00b6\n\n\nIf you have retrieved some data via a\n\nread()\n operation, then you\ncan update the retrieved records directly, as shown in the example below:\n\n\nimport { City, modelManager } from './creating_models';\n\n(async () => {\n\n    await modelManager.create(new City({ name: 'Wellington' }));\n    await modelManager.create(new City({ name: 'Auckland' }));\n    await modelManager.create(new City({ name: 'Hamilton' }));\n    await modelManager.create(new City({ name: 'Christchurch' }));\n\n    // Retrieve Auckland's record\n    const cities = await modelManager.read(City, { where: {\n            name: 'Auckland'\n    }});\n    console.log('Original Record:', cities.results[0]);\n\n    // Change it's name and trigger an update\n    const auckland = cities.results[0];\n    auckland.name = 'City of Sails';\n\n    await modelManager.update(auckland);\n\n    // Check that Auckland's record has been updated\n    const cityRetrieved = await modelManager.read(City, { where: {\n            name: 'City of Sails'\n    }});\n    console.log('Updated Record:', cityRetrieved.results[0]);\n\n})();\n\n\n\n\nNOTE:\n In order to update records without specifying a \nwhere\n clause, your\nmodel must have a field with \nprimaryKey: true\n set.\n\n\nUpdating Data with a Where clause\n\u00b6\n\n\nIf you wish to modify one or more fields across \nmultiple records\n, you can\nuse the \nwhere\n clause, as shown in the example below:\n\n\nimport { Post, modelManager, createData } from './post_model';\n\n(async () => {\n    await createData();\n\n    // Count unpublished posts\n    const unpublishedPosts = await modelManager.read(Post, {\n        where: {\n            published: false\n        }\n    });\n    console.log('Number of unpublished posts:', unpublishedPosts.meta.totalCount);\n\n    // Publish all unpublished posts!\n    const publishResult = await modelManager.update(\n        new Post({\n            published: true\n        }),\n        {\n            where: {\n                published: false\n            }\n        }\n    );\n    console.log('Updated records:', publishResult.meta.totalCount);\n\n})();",
            "title": "Updating Model Data"
        },
        {
            "location": "/models/updating_data/#updating-model-data",
            "text": "You can update records using the ModelManager.update() \nmethod. There are a couple of ways to use it:",
            "title": "Updating Model Data"
        },
        {
            "location": "/models/updating_data/#updating-data-from-reads",
            "text": "If you have retrieved some data via a read()  operation, then you\ncan update the retrieved records directly, as shown in the example below:  import { City, modelManager } from './creating_models';\n\n(async () => {\n\n    await modelManager.create(new City({ name: 'Wellington' }));\n    await modelManager.create(new City({ name: 'Auckland' }));\n    await modelManager.create(new City({ name: 'Hamilton' }));\n    await modelManager.create(new City({ name: 'Christchurch' }));\n\n    // Retrieve Auckland's record\n    const cities = await modelManager.read(City, { where: {\n            name: 'Auckland'\n    }});\n    console.log('Original Record:', cities.results[0]);\n\n    // Change it's name and trigger an update\n    const auckland = cities.results[0];\n    auckland.name = 'City of Sails';\n\n    await modelManager.update(auckland);\n\n    // Check that Auckland's record has been updated\n    const cityRetrieved = await modelManager.read(City, { where: {\n            name: 'City of Sails'\n    }});\n    console.log('Updated Record:', cityRetrieved.results[0]);\n\n})();  NOTE:  In order to update records without specifying a  where  clause, your\nmodel must have a field with  primaryKey: true  set.",
            "title": "Updating Data from Reads"
        },
        {
            "location": "/models/updating_data/#updating-data-with-a-where-clause",
            "text": "If you wish to modify one or more fields across  multiple records , you can\nuse the  where  clause, as shown in the example below:  import { Post, modelManager, createData } from './post_model';\n\n(async () => {\n    await createData();\n\n    // Count unpublished posts\n    const unpublishedPosts = await modelManager.read(Post, {\n        where: {\n            published: false\n        }\n    });\n    console.log('Number of unpublished posts:', unpublishedPosts.meta.totalCount);\n\n    // Publish all unpublished posts!\n    const publishResult = await modelManager.update(\n        new Post({\n            published: true\n        }),\n        {\n            where: {\n                published: false\n            }\n        }\n    );\n    console.log('Updated records:', publishResult.meta.totalCount);\n\n})();",
            "title": "Updating Data with a Where clause"
        },
        {
            "location": "/models/deleting_data/",
            "text": "Deleting Model Data\n\u00b6\n\n\nYou can delete records using the\n\nModelManager.remove()\n\nmethod ('delete' is a reserved word in JavaScript). There are a couple of ways to use the remove() method:\n\n\nDeleting Data from Reads\n\u00b6\n\n\nIf you have retrieved some data via a\n\nread()\n operation, then you\ncan remove the retrieved records directly, as shown in the example below:\n\n\n\nimport { City, modelManager } from './creating_models';\n\n(async () => {\n\n    await modelManager.create(new City({ name: 'Wellington' }));\n    await modelManager.create(new City({ name: 'Auckland' }));\n    await modelManager.create(new City({ name: 'Hamilton' }));\n    await modelManager.create(new City({ name: 'Christchurch' }));\n\n    const origRecords = await modelManager.read(City);\n    console.log('Original Records:', origRecords.results);\n\n    // Retrieve Auckland\n    const cities = await modelManager.read(City, { where: {\n        name: 'Auckland'\n    }});\n\n    // Remove it!\n    await modelManager.remove(cities.results[0]);\n\n    // Retrieve remaining records\n    const newRecords = await modelManager.read(City);\n    console.log('Remaining Records:', newRecords.results);\n\n})();\n\n\n\n\nNOTE:\n In order to remove records without specifying a \nwhere\n clause, your\nmodel must have a field with \nprimaryKey: true\n set.\n\n\nDeleting Data with a Where clause\n\u00b6\n\n\nIf you wish to delete multiple records, you can\nuse the \nwhere\n clause, as shown in the example below:\n\n\nimport { Post, modelManager, createData } from './post_model';\n\n(async () => {\n    await createData();\n\n    // Count unpublished posts\n    const unpublishedPosts = await modelManager.read(Post, {\n        where: {\n            published: false\n        }\n    });\n    console.log('Number of unpublished posts:', unpublishedPosts.meta.totalCount);\n\n    // Delete all unpublished posts\n    const deleteResult = await modelManager.remove(new Post(), {\n        where: {\n            published: false\n        }\n    });\n    console.log('Deleted records:', deleteResult.meta.totalCount);\n\n})();",
            "title": "Deleting Model Data"
        },
        {
            "location": "/models/deleting_data/#deleting-model-data",
            "text": "You can delete records using the ModelManager.remove() \nmethod ('delete' is a reserved word in JavaScript). There are a couple of ways to use the remove() method:",
            "title": "Deleting Model Data"
        },
        {
            "location": "/models/deleting_data/#deleting-data-from-reads",
            "text": "If you have retrieved some data via a read()  operation, then you\ncan remove the retrieved records directly, as shown in the example below:  \nimport { City, modelManager } from './creating_models';\n\n(async () => {\n\n    await modelManager.create(new City({ name: 'Wellington' }));\n    await modelManager.create(new City({ name: 'Auckland' }));\n    await modelManager.create(new City({ name: 'Hamilton' }));\n    await modelManager.create(new City({ name: 'Christchurch' }));\n\n    const origRecords = await modelManager.read(City);\n    console.log('Original Records:', origRecords.results);\n\n    // Retrieve Auckland\n    const cities = await modelManager.read(City, { where: {\n        name: 'Auckland'\n    }});\n\n    // Remove it!\n    await modelManager.remove(cities.results[0]);\n\n    // Retrieve remaining records\n    const newRecords = await modelManager.read(City);\n    console.log('Remaining Records:', newRecords.results);\n\n})();  NOTE:  In order to remove records without specifying a  where  clause, your\nmodel must have a field with  primaryKey: true  set.",
            "title": "Deleting Data from Reads"
        },
        {
            "location": "/models/deleting_data/#deleting-data-with-a-where-clause",
            "text": "If you wish to delete multiple records, you can\nuse the  where  clause, as shown in the example below:  import { Post, modelManager, createData } from './post_model';\n\n(async () => {\n    await createData();\n\n    // Count unpublished posts\n    const unpublishedPosts = await modelManager.read(Post, {\n        where: {\n            published: false\n        }\n    });\n    console.log('Number of unpublished posts:', unpublishedPosts.meta.totalCount);\n\n    // Delete all unpublished posts\n    const deleteResult = await modelManager.remove(new Post(), {\n        where: {\n            published: false\n        }\n    });\n    console.log('Deleted records:', deleteResult.meta.totalCount);\n\n})();",
            "title": "Deleting Data with a Where clause"
        },
        {
            "location": "/components/rev-models/",
            "text": "rev-models - RevJS Data Models\n\u00b6\n\n\nThe \nrev-models\n module provides the following:\n\n\n\n\nA set of \nBuilt-in Field Types\n for defining your\n   data models\n\n\nA \nModelManager\n object, which holds the list of\n   your registered models, and provides functions for \ncreate\n, \nread\n,\n   \nupdate\n and \ndelete\n.\n\n\nAn \nin-memory\n storage backend, so you can play with RevJS functions without\n   needing to set up a database.\n\n\n\n\nJump to the \nrev-models API Documentation\n\n\nExample\n\u00b6\n\n\nThe example below registers a simple data class with some basic validation\nrules, creates some data, and reads it back.\n\n\n\nimport {\n    AutoNumberField, TextField, SelectField,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define model\n\nconst POST_STATUS = [\n    ['draft', 'Draft'],\n    ['published', 'Published']\n];\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField({ minLength: 5, maxLength: 100 })\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @SelectField({ selection: POST_STATUS })\n        status: string;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n(async () => {\n\n    // Create some data\n\n    await modelManager.create(new Post({\n        title: 'My First Post',\n        body: 'This is a really cool post made in RevJS',\n        status: 'draft'\n    }));\n\n    await modelManager.create(new Post({\n        title: 'RevJS is awesome!',\n        body: 'I should use it for ALL TEH THINGZZZ!',\n        status: 'published'\n    }));\n\n    // Read it back\n\n    const res = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { title: { _like: '%RevJS%' }},\n                { body: { _like: '%RevJS%' }}\n            ]\n        }\n    });\n\n    console.log(res.results);\n\n})();\n\n\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-models"
        },
        {
            "location": "/components/rev-models/#rev-models-revjs-data-models",
            "text": "The  rev-models  module provides the following:   A set of  Built-in Field Types  for defining your\n   data models  A  ModelManager  object, which holds the list of\n   your registered models, and provides functions for  create ,  read ,\n    update  and  delete .  An  in-memory  storage backend, so you can play with RevJS functions without\n   needing to set up a database.   Jump to the  rev-models API Documentation",
            "title": "rev-models - RevJS Data Models"
        },
        {
            "location": "/components/rev-models/#example",
            "text": "The example below registers a simple data class with some basic validation\nrules, creates some data, and reads it back.  \nimport {\n    AutoNumberField, TextField, SelectField,\n    ModelManager, InMemoryBackend\n} from 'rev-models';\n\n// Define model\n\nconst POST_STATUS = [\n    ['draft', 'Draft'],\n    ['published', 'Published']\n];\n\nexport class Post {\n    @AutoNumberField({ primaryKey: true })\n        id: number;\n    @TextField({ minLength: 5, maxLength: 100 })\n        title: string;\n    @TextField({ multiLine: true })\n        body: string;\n    @SelectField({ selection: POST_STATUS })\n        status: string;\n\n    constructor(data?: Partial<Post>) {\n        Object.assign(this, data);\n    }\n}\n\n// Create ModelManager\n\nexport const modelManager = new ModelManager();\nmodelManager.registerBackend('default', new InMemoryBackend());\nmodelManager.register(Post);\n\n(async () => {\n\n    // Create some data\n\n    await modelManager.create(new Post({\n        title: 'My First Post',\n        body: 'This is a really cool post made in RevJS',\n        status: 'draft'\n    }));\n\n    await modelManager.create(new Post({\n        title: 'RevJS is awesome!',\n        body: 'I should use it for ALL TEH THINGZZZ!',\n        status: 'published'\n    }));\n\n    // Read it back\n\n    const res = await modelManager.read(Post, {\n        where: {\n            _or: [\n                { title: { _like: '%RevJS%' }},\n                { body: { _like: '%RevJS%' }}\n            ]\n        }\n    });\n\n    console.log(res.results);\n\n})();",
            "title": "Example"
        },
        {
            "location": "/components/rev-models/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/components/rev-api/",
            "text": "rev-api\n\u00b6\n\n\n// TODO\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-api"
        },
        {
            "location": "/components/rev-api/#rev-api",
            "text": "// TODO",
            "title": "rev-api"
        },
        {
            "location": "/components/rev-api/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/components/rev-api-client/",
            "text": "rev-api-client\n\u00b6\n\n\n// TODO\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-api-client"
        },
        {
            "location": "/components/rev-api-client/#rev-api-client",
            "text": "// TODO",
            "title": "rev-api-client"
        },
        {
            "location": "/components/rev-api-client/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        },
        {
            "location": "/components/rev-ui/",
            "text": "rev-ui\n\u00b6\n\n\n// TODO\n\n\nContributing\n\u00b6\n\n\nWe are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a\n\nmail\n!",
            "title": "rev-ui"
        },
        {
            "location": "/components/rev-ui/#rev-ui",
            "text": "// TODO",
            "title": "rev-ui"
        },
        {
            "location": "/components/rev-ui/#contributing",
            "text": "We are actively looking to build a team around RevJS. If you are interesting in\ncontributing, fork us on github or drop us a mail !",
            "title": "Contributing"
        }
    ]
}